//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

/*++

Module Name:

    csmedia.h

Abstract:

    WDM-CSA Multimedia Definitions.

--*/

#if !defined(_CS_)
#error CS.H must be included before CSMEDIA.H
#endif // !defined(_CS_)

#if !defined(_CSMEDIA_)
#define _CSMEDIA_

typedef struct {
    CSPROPERTY      Property;
    CSMULTIPLE_ITEM MultipleItem;
} CSMULTIPLE_DATA_PROP, *PCSMULTIPLE_DATA_PROP;

#ifndef UNDER_CE

#define STATIC_CSMEDIUMSETID_MidiBus \
    0x05908040L, 0x3246, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("05908040-3246-11D0-A5D6-28DB04C10000", CSMEDIUMSETID_MidiBus);
#define CSMEDIUMSETID_MidiBus DEFINE_GUIDNAMED(CSMEDIUMSETID_MidiBus)

#define STATIC_CSMEDIUMSETID_VPBus \
    0xA18C15ECL, 0xCE43, 0x11D0, 0xAB, 0xE7, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("A18C15EC-CE43-11D0-ABE7-00A0C9223196", CSMEDIUMSETID_VPBus);
#define CSMEDIUMSETID_VPBus DEFINE_GUIDNAMED(CSMEDIUMSETID_VPBus)

#define STATIC_CSINTERFACESETID_Media \
    0x3A13EB40L, 0x30A7, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("3A13EB40-30A7-11D0-A5D6-28DB04C10000", CSINTERFACESETID_Media);
#define CSINTERFACESETID_Media DEFINE_GUIDNAMED(CSINTERFACESETID_Media)

typedef enum {
    CSINTERFACE_MEDIA_MUSIC,
    CSINTERFACE_MEDIA_WAVE_BUFFERED,
    CSINTERFACE_MEDIA_WAVE_QUEUED
} CSINTERFACE_MEDIA;


#if !defined(INIT_USBAUDIO_MID)
// {4e1cecd2-1679-463b-a72f-a5bf64c86eba}
#define INIT_USBAUDIO_MID(guid, id)\
{\
    (guid)->Data1 = 0x4e1cecd2 + (USHORT)(id);\
    (guid)->Data2 = 0x1679;\
    (guid)->Data3 = 0x463b;\
    (guid)->Data4[0] = 0xa7;\
    (guid)->Data4[1] = 0x2f;\
    (guid)->Data4[2] = 0xa5;\
    (guid)->Data4[3] = 0xbf;\
    (guid)->Data4[4] = 0x64;\
    (guid)->Data4[5] = 0xc8;\
    (guid)->Data4[6] = 0x6e;\
    (guid)->Data4[7] = 0xba;\
}

#define INIT_EXBUS_MANUFACTURER_ID INIT_USBAUDIO_MID

#define EXTRACT_USBAUDIO_MID(guid)\
    (USHORT)((guid)->Data1 - 0x4e1cecd2)
#define DEFINE_USBAUDIO_MID_GUID(id)\
    0x4e1cecd2+(USHORT)(id), 0x1679, 0x463b, 0xa7, 0x2f, 0xa5, 0xbf, 0x64, 0xc8, 0x6e, 0xba

#define IS_COMPATIBLE_USBAUDIO_MID(guid)\
    (((guid)->Data1 >= 0x4e1cecd2) &&\
    ((guid)->Data1 < 0x4e1cecd2 + 0xffff) &&\
    ((guid)->Data2 == 0x1679) &&\
    ((guid)->Data3 == 0x463b) &&\
    ((guid)->Data4[0] == 0xa7) &&\
    ((guid)->Data4[1] == 0x2f) &&\
    ((guid)->Data4[2] == 0xa5) &&\
    ((guid)->Data4[3] == 0xbf) &&\
    ((guid)->Data4[4] == 0x64) &&\
    ((guid)->Data4[5] == 0xc8) &&\
    ((guid)->Data4[6] == 0x6e) &&\
    ((guid)->Data4[7] == 0xba))
#endif // !defined(INIT_USBAUDIO_MID)

#if !defined(INIT_USBAUDIO_PID)
// {abcc5a5e-c263-463b-a72f-a5bf64c86eba}
#define INIT_USBAUDIO_PID(guid, id)\
{\
    (guid)->Data1 = 0xabcc5a5e + (USHORT)(id);\
    (guid)->Data2 = 0xc263;\
    (guid)->Data3 = 0x463b;\
    (guid)->Data4[0] = 0xa7;\
    (guid)->Data4[1] = 0x2f;\
    (guid)->Data4[2] = 0xa5;\
    (guid)->Data4[3] = 0xbf;\
    (guid)->Data4[4] = 0x64;\
    (guid)->Data4[5] = 0xc8;\
    (guid)->Data4[6] = 0x6e;\
    (guid)->Data4[7] = 0xba;\
}

#define INIT_EXBUS_PRODUCT_ID INIT_USBAUDIO_PID

#define EXTRACT_USBAUDIO_PID(guid)\
    (USHORT)((guid)->Data1 - 0xabcc5a5e)
#define DEFINE_USBAUDIO_PID_GUID(id)\
    0xabcc5a5e+(USHORT)(id), 0xc263, 0x463b, 0xa7, 0x2f, 0xa5, 0xbf, 0x64, 0xc8, 0x6e, 0xba

#define IS_COMPATIBLE_USBAUDIO_PID(guid)\
    (((guid)->Data1 >= 0xabcc5a5e) &&\
    ((guid)->Data1 < 0xabcc5a5e + 0xffff) &&\
    ((guid)->Data2 == 0xc263) &&\
    ((guid)->Data3 == 0x463b) &&\
    ((guid)->Data4[0] == 0xa7) &&\
    ((guid)->Data4[1] == 0x2f) &&\
    ((guid)->Data4[2] == 0xa5) &&\
    ((guid)->Data4[3] == 0xbf) &&\
    ((guid)->Data4[4] == 0x64) &&\
    ((guid)->Data4[5] == 0xc8) &&\
    ((guid)->Data4[6] == 0x6e) &&\
    ((guid)->Data4[7] == 0xba))
#endif // !defined(INIT_USBAUDIO_PID)

#if !defined(INIT_USBAUDIO_PRODUCT_NAME)
// {FC575048-2E08-463B-A72F-A5BF64C86EBA}
#define INIT_USBAUDIO_PRODUCT_NAME(guid, vid, pid, strIndex)\
{\
    (guid)->Data1 = 0XFC575048 + (USHORT)(vid);\
    (guid)->Data2 = 0x2E08     + (USHORT)(pid);\
    (guid)->Data3 = 0x463B     + (USHORT)(strIndex);\
    (guid)->Data4[0] = 0xA7;\
    (guid)->Data4[1] = 0x2F;\
    (guid)->Data4[2] = 0xA5;\
    (guid)->Data4[3] = 0xBF;\
    (guid)->Data4[4] = 0x64;\
    (guid)->Data4[5] = 0xC8;\
    (guid)->Data4[6] = 0x6E;\
    (guid)->Data4[7] = 0xBA;\
}

#define INIT_EXBUS_PRODUCT_NAME INIT_USBAUDIO_PRODUCT_NAME

#define DEFINE_USBAUDIO_PRODUCT_NAME(vid, pid, strIndex)\
    0xFC575048+(USHORT)(vid), 0x2E08+(USHORT)(pid), 0x463B+(USHORT)(strIndex), 0xA7, 0x2F, 0xA5, 0xBF, 0x64, 0xC8, 0x6E, 0xBA
#endif // !defined(INIT_USBAUDIO_PRODUCT_NAME)


// USB Audio Component ID
#define STATIC_CSCOMPONENTID_USBAUDIO \
    0x8F1275F0, 0x26E9, 0x4264, 0xBA, 0x4D, 0x39, 0xFF, 0xF0, 0x1D, 0x94, 0xAA
DEFINE_GUIDSTRUCT("8F1275F0-26E9-4264-BA4D-39FFF01D94AA", CSCOMPONENTID_USBAUDIO);
#define CSCOMPONENTID_USBAUDIO DEFINE_GUIDNAMED(CSCOMPONENTID_USBAUDIO)

// AV/C Audio Component ID
#define STATIC_CSCOMPONENTID_AVCAUDIO \
    0xc1ca31ed, 0xbe33, 0x4924, 0xa3, 0xf5, 0x53, 0x92, 0x54, 0x31, 0xf1, 0x92
DEFINE_GUIDSTRUCT("C1CA31ED-BE33-4924-A3F5-53925431F192", CSCOMPONENTID_AVCAUDIO);
#define CSCOMPONENTID_AVCAUDIO DEFINE_GUIDNAMED(CSCOMPONENTID_AVCAUDIO)

// USB Terminals
#define INIT_USB_TERMINAL(guid, id)\
{\
    (guid)->Data1 = 0xDFF219E0 + (USHORT)(id);\
    (guid)->Data2 = 0xF70F;\
    (guid)->Data3 = 0x11D0;\
    (guid)->Data4[0] = 0xb9;\
    (guid)->Data4[1] = 0x17;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_USB_TERMINAL(guid)\
    (USHORT)((guid)->Data1 - 0xDFF219E0)
#define DEFINE_USB_TERMINAL_GUID(id)\
    0xDFF219E0+(USHORT)(id), 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_CSNODETYPE_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0201)
DEFINE_GUIDSTRUCT("DFF21BE1-F70F-11D0-B917-00A0C9223196", CSNODETYPE_MICROPHONE);
#define CSNODETYPE_MICROPHONE DEFINE_GUIDNAMED(CSNODETYPE_MICROPHONE)

#define STATIC_CSNODETYPE_DESKTOP_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0202)
DEFINE_GUIDSTRUCT("DFF21BE2-F70F-11D0-B917-00A0C9223196", CSNODETYPE_DESKTOP_MICROPHONE);
#define CSNODETYPE_DESKTOP_MICROPHONE DEFINE_GUIDNAMED(CSNODETYPE_DESKTOP_MICROPHONE)

#define STATIC_CSNODETYPE_PERSONAL_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0203)
DEFINE_GUIDSTRUCT("DFF21BE3-F70F-11D0-B917-00A0C9223196", CSNODETYPE_PERSONAL_MICROPHONE);
#define CSNODETYPE_PERSONAL_MICROPHONE DEFINE_GUIDNAMED(CSNODETYPE_PERSONAL_MICROPHONE)

#define STATIC_CSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0204)
DEFINE_GUIDSTRUCT("DFF21BE4-F70F-11D0-B917-00A0C9223196", CSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE);
#define CSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE DEFINE_GUIDNAMED(CSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE)

#define STATIC_CSNODETYPE_MICROPHONE_ARRAY\
    DEFINE_USB_TERMINAL_GUID(0x0205)
DEFINE_GUIDSTRUCT("DFF21BE5-F70F-11D0-B917-00A0C9223196", CSNODETYPE_MICROPHONE_ARRAY);
#define CSNODETYPE_MICROPHONE_ARRAY DEFINE_GUIDNAMED(CSNODETYPE_MICROPHONE_ARRAY)

#define STATIC_CSNODETYPE_PROCESSING_MICROPHONE_ARRAY\
    DEFINE_USB_TERMINAL_GUID(0x0206)
DEFINE_GUIDSTRUCT("DFF21BE6-F70F-11D0-B917-00A0C9223196", CSNODETYPE_PROCESSING_MICROPHONE_ARRAY);
#define CSNODETYPE_PROCESSING_MICROPHONE_ARRAY DEFINE_GUIDNAMED(CSNODETYPE_PROCESSING_MICROPHONE_ARRAY)

#define STATIC_CSCATEGORY_MICROPHONE_ARRAY_PROCESSOR \
    0x830a44f2, 0xa32d, 0x476b,  0xbe, 0x97, 0x42, 0x84, 0x56, 0x73, 0xb3, 0x5a
DEFINE_GUIDSTRUCT("830a44f2-a32d-476b-be97-42845673b35a", CSCATEGORY_MICROPHONE_ARRAY_PROCESSOR);
#define CSCATEGORY_MICROPHONE_ARRAY_PROCESSOR DEFINE_GUIDNAMED(CSCATEGORY_MICROPHONE_ARRAY_PROCESSOR)

#define STATIC_CSNODETYPE_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0301)
DEFINE_GUIDSTRUCT("DFF21CE1-F70F-11D0-B917-00A0C9223196", CSNODETYPE_SPEAKER);
#define CSNODETYPE_SPEAKER DEFINE_GUIDNAMED(CSNODETYPE_SPEAKER)

#define STATIC_CSNODETYPE_HEADPHONES\
    DEFINE_USB_TERMINAL_GUID(0x0302)
DEFINE_GUIDSTRUCT("DFF21CE2-F70F-11D0-B917-00A0C9223196", CSNODETYPE_HEADPHONES);
#define CSNODETYPE_HEADPHONES DEFINE_GUIDNAMED(CSNODETYPE_HEADPHONES)

#define STATIC_CSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x0303)
DEFINE_GUIDSTRUCT("DFF21CE3-F70F-11D0-B917-00A0C9223196", CSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO);
#define CSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO DEFINE_GUIDNAMED(CSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO)

#define STATIC_CSNODETYPE_DESKTOP_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0304)
DEFINE_GUIDSTRUCT("DFF21CE4-F70F-11D0-B917-00A0C9223196", CSNODETYPE_DESKTOP_SPEAKER);
#define CSNODETYPE_DESKTOP_SPEAKER DEFINE_GUIDNAMED(CSNODETYPE_DESKTOP_SPEAKER)

#define STATIC_CSNODETYPE_ROOM_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0305)
DEFINE_GUIDSTRUCT("DFF21CE5-F70F-11D0-B917-00A0C9223196", CSNODETYPE_ROOM_SPEAKER);
#define CSNODETYPE_ROOM_SPEAKER DEFINE_GUIDNAMED(CSNODETYPE_ROOM_SPEAKER)

#define STATIC_CSNODETYPE_COMMUNICATION_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0306)
DEFINE_GUIDSTRUCT("DFF21CE6-F70F-11D0-B917-00A0C9223196", CSNODETYPE_COMMUNICATION_SPEAKER);
#define CSNODETYPE_COMMUNICATION_SPEAKER DEFINE_GUIDNAMED(CSNODETYPE_COMMUNICATION_SPEAKER)

#define STATIC_CSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0307)
DEFINE_GUIDSTRUCT("DFF21CE7-F70F-11D0-B917-00A0C9223196", CSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER);
#define CSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER DEFINE_GUIDNAMED(CSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER)

#define STATIC_CSNODETYPE_HANDSET\
    DEFINE_USB_TERMINAL_GUID(0x0401)
DEFINE_GUIDSTRUCT("DFF21DE1-F70F-11D0-B917-00A0C9223196", CSNODETYPE_HANDSET);
#define CSNODETYPE_HANDSET DEFINE_GUIDNAMED(CSNODETYPE_HANDSET)

#define STATIC_CSNODETYPE_HEADSET\
    DEFINE_USB_TERMINAL_GUID(0x0402)
DEFINE_GUIDSTRUCT("DFF21DE2-F70F-11D0-B917-00A0C9223196", CSNODETYPE_HEADSET);
#define CSNODETYPE_HEADSET DEFINE_GUIDNAMED(CSNODETYPE_HEADSET)

#define STATIC_CSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION\
    DEFINE_USB_TERMINAL_GUID(0x0403)
DEFINE_GUIDSTRUCT("DFF21DE3-F70F-11D0-B917-00A0C9223196", CSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION);
#define CSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION DEFINE_GUIDNAMED(CSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION)

#define STATIC_CSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0404)
DEFINE_GUIDSTRUCT("DFF21DE4-F70F-11D0-B917-00A0C9223196", CSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE);
#define CSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE DEFINE_GUIDNAMED(CSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE)

#define STATIC_CSNODETYPE_ECHO_CANCELING_SPEAKERPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0405)
DEFINE_GUIDSTRUCT("DFF21DE5-F70F-11D0-B917-00A0C9223196", CSNODETYPE_ECHO_CANCELING_SPEAKERPHONE);
#define CSNODETYPE_ECHO_CANCELING_SPEAKERPHONE DEFINE_GUIDNAMED(CSNODETYPE_ECHO_CANCELING_SPEAKERPHONE)

#define STATIC_CSNODETYPE_PHONE_LINE\
    DEFINE_USB_TERMINAL_GUID(0x0501)
DEFINE_GUIDSTRUCT("DFF21EE1-F70F-11D0-B917-00A0C9223196", CSNODETYPE_PHONE_LINE);
#define CSNODETYPE_PHONE_LINE DEFINE_GUIDNAMED(CSNODETYPE_PHONE_LINE)

#define STATIC_CSNODETYPE_TELEPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0502)
DEFINE_GUIDSTRUCT("DFF21EE2-F70F-11D0-B917-00A0C9223196", CSNODETYPE_TELEPHONE);
#define CSNODETYPE_TELEPHONE DEFINE_GUIDNAMED(CSNODETYPE_TELEPHONE)

#define STATIC_CSNODETYPE_DOWN_LINE_PHONE\
    DEFINE_USB_TERMINAL_GUID(0x0503)
DEFINE_GUIDSTRUCT("DFF21EE3-F70F-11D0-B917-00A0C9223196", CSNODETYPE_DOWN_LINE_PHONE);
#define CSNODETYPE_DOWN_LINE_PHONE DEFINE_GUIDNAMED(CSNODETYPE_DOWN_LINE_PHONE)

#define STATIC_CSNODETYPE_ANALOG_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x601)
DEFINE_GUIDSTRUCT("DFF21FE1-F70F-11D0-B917-00A0C9223196", CSNODETYPE_ANALOG_CONNECTOR);
#define CSNODETYPE_ANALOG_CONNECTOR DEFINE_GUIDNAMED(CSNODETYPE_ANALOG_CONNECTOR)

#define STATIC_CSNODETYPE_DIGITAL_AUDIO_INTERFACE\
    DEFINE_USB_TERMINAL_GUID(0x0602)
DEFINE_GUIDSTRUCT("DFF21FE2-F70F-11D0-B917-00A0C9223196", CSNODETYPE_DIGITAL_AUDIO_INTERFACE);
#define CSNODETYPE_DIGITAL_AUDIO_INTERFACE DEFINE_GUIDNAMED(CSNODETYPE_DIGITAL_AUDIO_INTERFACE)

#define STATIC_CSNODETYPE_LINE_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x0603)
DEFINE_GUIDSTRUCT("DFF21FE3-F70F-11D0-B917-00A0C9223196", CSNODETYPE_LINE_CONNECTOR);
#define CSNODETYPE_LINE_CONNECTOR DEFINE_GUIDNAMED(CSNODETYPE_LINE_CONNECTOR)

#define STATIC_CSNODETYPE_LEGACY_AUDIO_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x0604)
DEFINE_GUIDSTRUCT("DFF21FE4-F70F-11D0-B917-00A0C9223196", CSNODETYPE_LEGACY_AUDIO_CONNECTOR);
#define CSNODETYPE_LEGACY_AUDIO_CONNECTOR DEFINE_GUIDNAMED(CSNODETYPE_LEGACY_AUDIO_CONNECTOR)

#define STATIC_CSNODETYPE_SPDIF_INTERFACE\
    DEFINE_USB_TERMINAL_GUID(0x0605)
DEFINE_GUIDSTRUCT("DFF21FE5-F70F-11D0-B917-00A0C9223196", CSNODETYPE_SPDIF_INTERFACE);
#define CSNODETYPE_SPDIF_INTERFACE DEFINE_GUIDNAMED(CSNODETYPE_SPDIF_INTERFACE)

#define STATIC_CSNODETYPE_1394_DA_STREAM\
    DEFINE_USB_TERMINAL_GUID(0x0606)
DEFINE_GUIDSTRUCT("DFF21FE6-F70F-11D0-B917-00A0C9223196", CSNODETYPE_1394_DA_STREAM);
#define CSNODETYPE_1394_DA_STREAM DEFINE_GUIDNAMED(CSNODETYPE_1394_DA_STREAM)

#define STATIC_CSNODETYPE_1394_DV_STREAM_SOUNDTRACK\
    DEFINE_USB_TERMINAL_GUID(0x0607)
DEFINE_GUIDSTRUCT("DFF21FE7-F70F-11D0-B917-00A0C9223196", CSNODETYPE_1394_DV_STREAM_SOUNDTRACK);
#define CSNODETYPE_1394_DV_STREAM_SOUNDTRACK DEFINE_GUIDNAMED(CSNODETYPE_1394_DV_STREAM_SOUNDTRACK)

#define STATIC_CSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE\
    DEFINE_USB_TERMINAL_GUID(0x0701)
DEFINE_GUIDSTRUCT("DFF220E1-F70F-11D0-B917-00A0C9223196", CSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE);
#define CSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE DEFINE_GUIDNAMED(CSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE)

#define STATIC_CSNODETYPE_EQUALIZATION_NOISE\
    DEFINE_USB_TERMINAL_GUID(0x0702)
DEFINE_GUIDSTRUCT("DFF220E2-F70F-11D0-B917-00A0C9223196", CSNODETYPE_EQUALIZATION_NOISE);
#define CSNODETYPE_EQUALIZATION_NOISE DEFINE_GUIDNAMED(CSNODETYPE_EQUALIZATION_NOISE)

#define STATIC_CSNODETYPE_CD_PLAYER\
    DEFINE_USB_TERMINAL_GUID(0x0703)
DEFINE_GUIDSTRUCT("DFF220E3-F70F-11D0-B917-00A0C9223196", CSNODETYPE_CD_PLAYER);
#define CSNODETYPE_CD_PLAYER DEFINE_GUIDNAMED(CSNODETYPE_CD_PLAYER)

#define STATIC_CSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE\
    DEFINE_USB_TERMINAL_GUID(0x0704)
DEFINE_GUIDSTRUCT("DFF220E4-F70F-11D0-B917-00A0C9223196", CSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE);
#define CSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE DEFINE_GUIDNAMED(CSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE)

#define STATIC_CSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE\
    DEFINE_USB_TERMINAL_GUID(0x0705)
DEFINE_GUIDSTRUCT("DFF220E5-F70F-11D0-B917-00A0C9223196", CSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE);
#define CSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE DEFINE_GUIDNAMED(CSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE)

#define STATIC_CSNODETYPE_MINIDISK\
    DEFINE_USB_TERMINAL_GUID(0x0706)
DEFINE_GUIDSTRUCT("DFF220E6-F70F-11D0-B917-00A0C9223196", CSNODETYPE_MINIDISK);
#define CSNODETYPE_MINIDISK DEFINE_GUIDNAMED(CSNODETYPE_MINIDISK)

#define STATIC_CSNODETYPE_ANALOG_TAPE\
    DEFINE_USB_TERMINAL_GUID(0x0707)
DEFINE_GUIDSTRUCT("DFF220E7-F70F-11D0-B917-00A0C9223196", CSNODETYPE_ANALOG_TAPE);
#define CSNODETYPE_ANALOG_TAPE DEFINE_GUIDNAMED(CSNODETYPE_ANALOG_TAPE)

#define STATIC_CSNODETYPE_PHONOGRAPH\
    DEFINE_USB_TERMINAL_GUID(0x0708)
DEFINE_GUIDSTRUCT("DFF220E8-F70F-11D0-B917-00A0C9223196", CSNODETYPE_PHONOGRAPH);
#define CSNODETYPE_PHONOGRAPH DEFINE_GUIDNAMED(CSNODETYPE_PHONOGRAPH)

#define STATIC_CSNODETYPE_VCR_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x0708)
DEFINE_GUIDSTRUCT("DFF220E9-F70F-11D0-B917-00A0C9223196", CSNODETYPE_VCR_AUDIO);
#define CSNODETYPE_VCR_AUDIO DEFINE_GUIDNAMED(CSNODETYPE_VCR_AUDIO)

#define STATIC_CSNODETYPE_VIDEO_DISC_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070A)
DEFINE_GUIDSTRUCT("DFF220EA-F70F-11D0-B917-00A0C9223196", CSNODETYPE_VIDEO_DISC_AUDIO);
#define CSNODETYPE_VIDEO_DISC_AUDIO DEFINE_GUIDNAMED(CSNODETYPE_VIDEO_DISC_AUDIO)

#define STATIC_CSNODETYPE_DVD_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070B)
DEFINE_GUIDSTRUCT("DFF220EB-F70F-11D0-B917-00A0C9223196", CSNODETYPE_DVD_AUDIO);
#define CSNODETYPE_DVD_AUDIO DEFINE_GUIDNAMED(CSNODETYPE_DVD_AUDIO)

#define STATIC_CSNODETYPE_TV_TUNER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070C)
DEFINE_GUIDSTRUCT("DFF220EC-F70F-11D0-B917-00A0C9223196", CSNODETYPE_TV_TUNER_AUDIO);
#define CSNODETYPE_TV_TUNER_AUDIO DEFINE_GUIDNAMED(CSNODETYPE_TV_TUNER_AUDIO)

#define STATIC_CSNODETYPE_SATELLITE_RECEIVER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070D)
DEFINE_GUIDSTRUCT("DFF220ED-F70F-11D0-B917-00A0C9223196", CSNODETYPE_SATELLITE_RECEIVER_AUDIO);
#define CSNODETYPE_SATELLITE_RECEIVER_AUDIO DEFINE_GUIDNAMED(CSNODETYPE_SATELLITE_RECEIVER_AUDIO)

#define STATIC_CSNODETYPE_CABLE_TUNER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070E)
DEFINE_GUIDSTRUCT("DFF220EE-F70F-11D0-B917-00A0C9223196", CSNODETYPE_CABLE_TUNER_AUDIO);
#define CSNODETYPE_CABLE_TUNER_AUDIO DEFINE_GUIDNAMED(CSNODETYPE_CABLE_TUNER_AUDIO)

#define STATIC_CSNODETYPE_DSS_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070F)
DEFINE_GUIDSTRUCT("DFF220EF-F70F-11D0-B917-00A0C9223196", CSNODETYPE_DSS_AUDIO);
#define CSNODETYPE_DSS_AUDIO DEFINE_GUIDNAMED(CSNODETYPE_DSS_AUDIO)

#define STATIC_CSNODETYPE_RADIO_RECEIVER\
    DEFINE_USB_TERMINAL_GUID(0x0710)
DEFINE_GUIDSTRUCT("DFF220F0-F70F-11D0-B917-00A0C9223196", CSNODETYPE_RADIO_RECEIVER);
#define CSNODETYPE_RADIO_RECEIVER DEFINE_GUIDNAMED(CSNODETYPE_RADIO_RECEIVER)

#define STATIC_CSNODETYPE_RADIO_TRANSMITTER\
    DEFINE_USB_TERMINAL_GUID(0x0711)
DEFINE_GUIDSTRUCT("DFF220F1-F70F-11D0-B917-00A0C9223196", CSNODETYPE_RADIO_TRANSMITTER);
#define CSNODETYPE_RADIO_TRANSMITTER DEFINE_GUIDNAMED(CSNODETYPE_RADIO_TRANSMITTER)

#define STATIC_CSNODETYPE_MULTITRACK_RECORDER\
    DEFINE_USB_TERMINAL_GUID(0x0712)
DEFINE_GUIDSTRUCT("DFF220F2-F70F-11D0-B917-00A0C9223196", CSNODETYPE_MULTITRACK_RECORDER);
#define CSNODETYPE_MULTITRACK_RECORDER DEFINE_GUIDNAMED(CSNODETYPE_MULTITRACK_RECORDER)

#define STATIC_CSNODETYPE_SYNTHESIZER\
    DEFINE_USB_TERMINAL_GUID(0x0713)
DEFINE_GUIDSTRUCT("DFF220F3-F70F-11D0-B917-00A0C9223196", CSNODETYPE_SYNTHESIZER);
#define CSNODETYPE_SYNTHESIZER DEFINE_GUIDNAMED(CSNODETYPE_SYNTHESIZER)

// USB MIDI Nodes
#define STATIC_CSNODETYPE_MIDI_JACK\
    0x265e0c3f, 0xfa39, 0x4df3, 0xab, 0x04, 0xbe, 0x01, 0xb9, 0x1e, 0x29, 0x9a
DEFINE_GUIDSTRUCT("265E0C3F-FA39-4df3-AB04-BE01B91E299A", CSNODETYPE_MIDI_JACK);
#define CSNODETYPE_MIDI_JACK DEFINE_GUIDNAMED(CSNODETYPE_MIDI_JACK)

#define STATIC_CSNODETYPE_MIDI_ELEMENT\
    0x01c6fe66, 0x6e48, 0x4c65, 0xac, 0x9b, 0x52, 0xdb, 0x5d, 0x65, 0x6c, 0x7e
DEFINE_GUIDSTRUCT("01C6FE66-6E48-4c65-AC9B-52DB5D656C7E", CSNODETYPE_MIDI_ELEMENT);
#define CSNODETYPE_MIDI_ELEMENT DEFINE_GUIDNAMED(CSNODETYPE_MIDI_ELEMENT)

// Microsoft's WDMAUD virtual swsynth pin name guid

#define STATIC_CSNODETYPE_SWSYNTH\
    0x423274A0L, 0x8B81, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("423274A0-8B81-11D1-A050-0000F8004788", CSNODETYPE_SWSYNTH);
#define CSNODETYPE_SWSYNTH DEFINE_GUIDNAMED(CSNODETYPE_SWSYNTH)

// Microsoft's SWMIDI midi pin and node name guid

#define STATIC_CSNODETYPE_SWMIDI\
    0xCB9BEFA0L, 0xA251, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("CB9BEFA0-A251-11D1-A050-0000F8004788", CSNODETYPE_SWMIDI);
#define CSNODETYPE_SWMIDI DEFINE_GUIDNAMED(CSNODETYPE_SWMIDI)

#define STATIC_CSNODETYPE_DRM_DESCRAMBLE\
    0xFFBB6E3FL, 0xCCFE, 0x4D84, 0x90, 0xD9, 0x42, 0x14, 0x18, 0xB0, 0x3A, 0x8E
DEFINE_GUIDSTRUCT("FFBB6E3F-CCFE-4D84-90D9-421418B03A8E", CSNODETYPE_DRM_DESCRAMBLE);
#define CSNODETYPE_DRM_DESCRAMBLE DEFINE_GUIDNAMED(CSNODETYPE_DRM_DESCRAMBLE)

// General categories
#define STATIC_CSCATEGORY_AUDIO \
    0x6994AD04L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD04-93EF-11D0-A3CC-00A0C9223196", CSCATEGORY_AUDIO);
#define CSCATEGORY_AUDIO DEFINE_GUIDNAMED(CSCATEGORY_AUDIO)

#define STATIC_CSCATEGORY_VIDEO \
    0x6994AD05L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD05-93EF-11D0-A3CC-00A0C9223196", CSCATEGORY_VIDEO);
#define CSCATEGORY_VIDEO DEFINE_GUIDNAMED(CSCATEGORY_VIDEO)

#define STATIC_CSCATEGORY_REALTIME \
    0xEB115FFCL, 0x10C8, 0x4964, 0x83, 0x1D, 0x6D, 0xCB, 0x02, 0xE6, 0xF2, 0x3F
DEFINE_GUIDSTRUCT("EB115FFC-10C8-4964-831D-6DCB02E6F23F", CSCATEGORY_REALTIME);
#define CSCATEGORY_REALTIME DEFINE_GUIDNAMED(CSCATEGORY_REALTIME)

#define STATIC_CSCATEGORY_TEXT \
    0x6994AD06L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD06-93EF-11D0-A3CC-00A0C9223196", CSCATEGORY_TEXT);
#define CSCATEGORY_TEXT DEFINE_GUIDNAMED(CSCATEGORY_TEXT)

#define STATIC_CSCATEGORY_NETWORK \
    0x67C9CC3CL, 0x69C4, 0x11D2, 0x87, 0x59, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("67C9CC3C-69C4-11D2-8759-00A0C9223196", CSCATEGORY_NETWORK);
#define CSCATEGORY_NETWORK DEFINE_GUIDNAMED(CSCATEGORY_NETWORK)

#define STATIC_CSCATEGORY_TOPOLOGY \
    0xDDA54A40L, 0x1E4C, 0x11D1, 0xA0, 0x50, 0x40, 0x57, 0x05, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("DDA54A40-1E4C-11D1-A050-405705C10000", CSCATEGORY_TOPOLOGY);
#define CSCATEGORY_TOPOLOGY DEFINE_GUIDNAMED(CSCATEGORY_TOPOLOGY)

#define STATIC_CSCATEGORY_VIRTUAL \
    0x3503EAC4L, 0x1F26, 0x11D1, 0x8A, 0xB0, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("3503EAC4-1F26-11D1-8AB0-00A0C9223196", CSCATEGORY_VIRTUAL);
#define CSCATEGORY_VIRTUAL DEFINE_GUIDNAMED(CSCATEGORY_VIRTUAL)

#define STATIC_CSCATEGORY_ACOUSTIC_ECHO_CANCEL \
    0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("BF963D80-C559-11D0-8A2B-00A0C9255AC1", CSCATEGORY_ACOUSTIC_ECHO_CANCEL);
#define CSCATEGORY_ACOUSTIC_ECHO_CANCEL DEFINE_GUIDNAMED(CSCATEGORY_ACOUSTIC_ECHO_CANCEL)

#define STATIC_CSCATEGORY_SYSAUDIO \
    0xA7C7A5B1L, 0x5AF3, 0x11D1, 0x9C, 0xED, 0x00, 0xA0, 0x24, 0xBF, 0x04, 0x07
DEFINE_GUIDSTRUCT("A7C7A5B1-5AF3-11D1-9CED-00A024BF0407", CSCATEGORY_SYSAUDIO);
#define CSCATEGORY_SYSAUDIO DEFINE_GUIDNAMED(CSCATEGORY_SYSAUDIO)

#define STATIC_CSCATEGORY_WDMAUD \
    0x3E227E76L, 0x690D, 0x11D2, 0x81, 0x61, 0x00, 0x00, 0xF8, 0x77, 0x5B, 0xF1
DEFINE_GUIDSTRUCT("3E227E76-690D-11D2-8161-0000F8775BF1", CSCATEGORY_WDMAUD);
#define CSCATEGORY_WDMAUD DEFINE_GUIDNAMED(CSCATEGORY_WDMAUD)

#define STATIC_CSCATEGORY_AUDIO_GFX \
    0x9BAF9572L, 0x340C, 0x11D3, 0xAB, 0xDC, 0x00, 0xA0, 0xC9, 0x0A, 0xB1, 0x6F
DEFINE_GUIDSTRUCT("9BAF9572-340C-11D3-ABDC-00A0C90AB16F", CSCATEGORY_AUDIO_GFX);
#define CSCATEGORY_AUDIO_GFX DEFINE_GUIDNAMED(CSCATEGORY_AUDIO_GFX)

#define STATIC_CSCATEGORY_AUDIO_SPLITTER \
    0x9EA331FAL, 0xB91B, 0x45F8, 0x92, 0x85, 0xBD, 0x2B, 0xC7, 0x7A, 0xFC, 0xDE
DEFINE_GUIDSTRUCT("9EA331FA-B91B-45F8-9285-BD2BC77AFCDE", CSCATEGORY_AUDIO_SPLITTER);
#define CSCATEGORY_AUDIO_SPLITTER DEFINE_GUIDNAMED(CSCATEGORY_AUDIO_SPLITTER)

#define STATIC_CSCATEGORY_SYNTHESIZER STATIC_CSNODETYPE_SYNTHESIZER
#define CSCATEGORY_SYNTHESIZER CSNODETYPE_SYNTHESIZER

#define STATIC_CSCATEGORY_DRM_DESCRAMBLE STATIC_CSNODETYPE_DRM_DESCRAMBLE
#define CSCATEGORY_DRM_DESCRAMBLE CSNODETYPE_DRM_DESCRAMBLE

#define STATIC_CSCATEGORY_AUDIO_DEVICE \
    0xFBF6F530L, 0x07B9, 0x11D2, 0xA7, 0x1E, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("FBF6F530-07B9-11D2-A71E-0000F8004788", CSCATEGORY_AUDIO_DEVICE);
#define CSCATEGORY_AUDIO_DEVICE DEFINE_GUIDNAMED(CSCATEGORY_AUDIO_DEVICE)

#define STATIC_CSCATEGORY_PREFERRED_WAVEOUT_DEVICE \
    0xD6C5066EL, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C5066E-72C1-11D2-9755-0000F8004788", CSCATEGORY_PREFERRED_WAVEOUT_DEVICE);
#define CSCATEGORY_PREFERRED_WAVEOUT_DEVICE DEFINE_GUIDNAMED(CSCATEGORY_PREFERRED_WAVEOUT_DEVICE)

#define STATIC_CSCATEGORY_PREFERRED_WAVEIN_DEVICE \
    0xD6C50671L, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C50671-72C1-11D2-9755-0000F8004788", CSCATEGORY_PREFERRED_WAVEIN_DEVICE);
#define CSCATEGORY_PREFERRED_WAVEIN_DEVICE DEFINE_GUIDNAMED(CSCATEGORY_PREFERRED_WAVEIN_DEVICE)

#define STATIC_CSCATEGORY_PREFERRED_MIDIOUT_DEVICE \
    0xD6C50674L, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C50674-72C1-11D2-9755-0000F8004788", CSCATEGORY_PREFERRED_MIDIOUT_DEVICE);
#define CSCATEGORY_PREFERRED_MIDIOUT_DEVICE DEFINE_GUIDNAMED(CSCATEGORY_PREFERRED_MIDIOUT_DEVICE)

// Special pin category for wdmaud

#define STATIC_CSCATEGORY_WDMAUD_USE_PIN_NAME \
    0x47A4FA20L, 0xA251, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("47A4FA20-A251-11D1-A050-0000F8004788", CSCATEGORY_WDMAUD_USE_PIN_NAME);
#define CSCATEGORY_WDMAUD_USE_PIN_NAME DEFINE_GUIDNAMED(CSCATEGORY_WDMAUD_USE_PIN_NAME)

// Escalante Platform Interface

#define STATIC_CSCATEGORY_ESCALANTE_PLATFORM_DRIVER \
    0x74f3aea8L, 0x9768, 0x11d1, 0x8e, 0x07, 0x00, 0xa0, 0xc9, 0x5e, 0xc2, 0x2e
DEFINE_GUIDSTRUCT("74f3aea8-9768-11d1-8e07-00a0c95ec22e", CSCATEGORY_ESCALANTE_PLATFORM_DRIVER);
#define CSCATEGORY_ESCALANTE_PLATFORM_DRIVER DEFINE_GUIDNAMED(CSCATEGORY_ESCALANTE_PLATFORM_DRIVER)

#endif //#ifndef UNDER_CE

// -- major types ---

// 'vids' == MEDIATYPE_Video,
#define STATIC_CSDATAFORMAT_TYPE_VIDEO\
    0x73646976L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73646976-0000-0010-8000-00aa00389b71", CSDATAFORMAT_TYPE_VIDEO);
#define CSDATAFORMAT_TYPE_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_VIDEO)

// 'auds' == MEDIATYPE_Audio
#define STATIC_CSDATAFORMAT_TYPE_AUDIO\
    0x73647561L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73647561-0000-0010-8000-00aa00389b71", CSDATAFORMAT_TYPE_AUDIO);
#define CSDATAFORMAT_TYPE_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_AUDIO)

#ifndef UNDER_CE

// 'txts' == MEDIATYPE_Text
#define STATIC_CSDATAFORMAT_TYPE_TEXT\
    0x73747874L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73747874-0000-0010-8000-00aa00389b71", CSDATAFORMAT_TYPE_TEXT);
#define CSDATAFORMAT_TYPE_TEXT DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_TEXT)

#if !defined( DEFINE_WAVEFORMATEX_GUID )
#define DEFINE_WAVEFORMATEX_GUID(x) (USHORT)(x), 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
#endif

#define STATIC_CSDATAFORMAT_SUBTYPE_WAVEFORMATEX\
    0x00000000L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000000-0000-0010-8000-00aa00389b71", CSDATAFORMAT_SUBTYPE_WAVEFORMATEX);
#define CSDATAFORMAT_SUBTYPE_WAVEFORMATEX DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_WAVEFORMATEX)

#define INIT_WAVEFORMATEX_GUID(Guid, x)\
{\
    *(Guid) = CSDATAFORMAT_SUBTYPE_WAVEFORMATEX;\
    (Guid)->Data1 = (USHORT)(x);\
}

#define EXTRACT_WAVEFORMATEX_ID(Guid)\
    (USHORT)((Guid)->Data1)

#define IS_VALID_WAVEFORMATEX_GUID(Guid)\
    (!memcmp(((PUSHORT)&CSDATAFORMAT_SUBTYPE_WAVEFORMATEX) + 1, ((PUSHORT)(Guid)) + 1, sizeof(GUID) - sizeof(USHORT)))

#if !defined(INIT_MMREG_MID)
//{d5a47fa7-6d98-11d1-a21a-00a0c9223196}
#define INIT_MMREG_MID(guid, id)\
{\
    (guid)->Data1 = 0xd5a47fa7 + (USHORT)(id);\
    (guid)->Data2 = 0x6d98;\
    (guid)->Data3 = 0x11d1;\
    (guid)->Data4[0] = 0xa2;\
    (guid)->Data4[1] = 0x1a;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_MMREG_MID(guid)\
    (USHORT)((guid)->Data1 - 0xd5a47fa7)
#define DEFINE_MMREG_MID_GUID(id)\
    0xd5a47fa7+(USHORT)(id), 0x6d98, 0x11d1, 0xa2, 0x1a, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96

#define IS_COMPATIBLE_MMREG_MID(guid)\
    (((guid)->Data1 >= 0xd5a47fa7) &&\
    ((guid)->Data1 < 0xd5a47fa7 + 0xffff) &&\
    ((guid)->Data2 == 0x6d98) &&\
    ((guid)->Data3 == 0x11d1) &&\
    ((guid)->Data4[0] == 0xa2) &&\
    ((guid)->Data4[1] == 0x1a) &&\
    ((guid)->Data4[2] == 0x00) &&\
    ((guid)->Data4[3] == 0xa0) &&\
    ((guid)->Data4[4] == 0xc9) &&\
    ((guid)->Data4[5] == 0x22) &&\
    ((guid)->Data4[6] == 0x31) &&\
    ((guid)->Data4[7] == 0x96))
#endif // !defined(INIT_MMREG_MID)

#if !defined(INIT_MMREG_PID)
//{e36dc2ac-6d9a-11d1-a21a-00a0c9223196}
#define INIT_MMREG_PID(guid, id)\
{\
    (guid)->Data1 = 0xe36dc2ac + (USHORT)(id);\
    (guid)->Data2 = 0x6d9a;\
    (guid)->Data3 = 0x11d1;\
    (guid)->Data4[0] = 0xa2;\
    (guid)->Data4[1] = 0x1a;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_MMREG_PID(guid)\
    (USHORT)((guid)->Data1 - 0xe36dc2ac)
#define DEFINE_MMREG_PID_GUID(id)\
    0xe36dc2ac+(USHORT)(id), 0x6d9a, 0x11d1, 0xa2, 0x1a, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96

#define IS_COMPATIBLE_MMREG_PID(guid)\
    (((guid)->Data1 >= 0xe36dc2ac) &&\
    ((guid)->Data1 < 0xe36dc2ac + 0xffff) &&\
    ((guid)->Data2 == 0x6d9a) &&\
    ((guid)->Data3 == 0x11d1) &&\
    ((guid)->Data4[0] == 0xa2) &&\
    ((guid)->Data4[1] == 0x1a) &&\
    ((guid)->Data4[2] == 0x00) &&\
    ((guid)->Data4[3] == 0xa0) &&\
    ((guid)->Data4[4] == 0xc9) &&\
    ((guid)->Data4[5] == 0x22) &&\
    ((guid)->Data4[6] == 0x31) &&\
    ((guid)->Data4[7] == 0x96))
#endif // !defined(INIT_MMREG_PID)

#define STATIC_CSDATAFORMAT_SUBTYPE_ANALOG\
    0x6dba3190L, 0x67bd, 0x11cf, 0xa0, 0xf7, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("6dba3190-67bd-11cf-a0f7-0020afd156e4", CSDATAFORMAT_SUBTYPE_ANALOG);
#define CSDATAFORMAT_SUBTYPE_ANALOG DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_ANALOG)

#define STATIC_CSDATAFORMAT_SUBTYPE_PCM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_PCM)
DEFINE_GUIDSTRUCT("00000001-0000-0010-8000-00aa00389b71", CSDATAFORMAT_SUBTYPE_PCM);
#define CSDATAFORMAT_SUBTYPE_PCM DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_PCM)

#if defined(_INC_MMREG)
#define STATIC_CSDATAFORMAT_SUBTYPE_IEEE_FLOAT\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_IEEE_FLOAT)
DEFINE_GUIDSTRUCT("00000003-0000-0010-8000-00aa00389b71", CSDATAFORMAT_SUBTYPE_IEEE_FLOAT);
#define CSDATAFORMAT_SUBTYPE_IEEE_FLOAT DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_IEEE_FLOAT)

#define STATIC_CSDATAFORMAT_SUBTYPE_DRM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_DRM)
DEFINE_GUIDSTRUCT("00000009-0000-0010-8000-00aa00389b71", CSDATAFORMAT_SUBTYPE_DRM);
#define CSDATAFORMAT_SUBTYPE_DRM DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_DRM)

#define STATIC_CSDATAFORMAT_SUBTYPE_ALAW\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_ALAW)
DEFINE_GUIDSTRUCT("00000006-0000-0010-8000-00aa00389b71", CSDATAFORMAT_SUBTYPE_ALAW);
#define CSDATAFORMAT_SUBTYPE_ALAW DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_ALAW)

#define STATIC_CSDATAFORMAT_SUBTYPE_MULAW\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_MULAW)
DEFINE_GUIDSTRUCT("00000007-0000-0010-8000-00aa00389b71", CSDATAFORMAT_SUBTYPE_MULAW);
#define CSDATAFORMAT_SUBTYPE_MULAW DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MULAW)

#define STATIC_CSDATAFORMAT_SUBTYPE_ADPCM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_ADPCM)
DEFINE_GUIDSTRUCT("00000002-0000-0010-8000-00aa00389b71", CSDATAFORMAT_SUBTYPE_ADPCM);
#define CSDATAFORMAT_SUBTYPE_ADPCM DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_ADPCM)

#endif //#ifndef UNDER_CE

#define STATIC_CSDATAFORMAT_SUBTYPE_MPEG\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_MPEG)
DEFINE_GUIDSTRUCT("00000050-0000-0010-8000-00aa00389b71", CSDATAFORMAT_SUBTYPE_MPEG);
#define CSDATAFORMAT_SUBTYPE_MPEG DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MPEG)

#ifndef UNDER_CE
#endif // defined(_INC_MMREG)

#define STATIC_CSDATAFORMAT_SPECIFIER_VC_ID\
    0xAD98D184L, 0xAAC3, 0x11D0, 0xA4, 0x1C, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("AD98D184-AAC3-11D0-A41C-00A0C9223196", CSDATAFORMAT_SPECIFIER_VC_ID);
#define CSDATAFORMAT_SPECIFIER_VC_ID DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_VC_ID)

#define STATIC_CSDATAFORMAT_SPECIFIER_WAVEFORMATEX\
    0x05589f81L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f81-c356-11ce-bf01-00aa0055595a", CSDATAFORMAT_SPECIFIER_WAVEFORMATEX);
#define CSDATAFORMAT_SPECIFIER_WAVEFORMATEX DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_WAVEFORMATEX)

#define STATIC_CSDATAFORMAT_SPECIFIER_DSOUND\
    0x518590a2L, 0xa184, 0x11d0, 0x85, 0x22, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("518590a2-a184-11d0-8522-00c04fd9baf3", CSDATAFORMAT_SPECIFIER_DSOUND);
#define CSDATAFORMAT_SPECIFIER_DSOUND DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_DSOUND)

#if defined(_INC_MMSYSTEM) || defined(_INC_MMREG)
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <pshpack1.h>
#endif
typedef struct {
    CSDATAFORMAT    DataFormat;
    WAVEFORMATEX    WaveFormatEx;
} CSDATAFORMAT_WAVEFORMATEX, *PCSDATAFORMAT_WAVEFORMATEX;

#ifndef _WAVEFORMATEXTENSIBLE_
#define _WAVEFORMATEXTENSIBLE_
typedef struct {
    WAVEFORMATEX    Format;
    union {
        WORD wValidBitsPerSample;       /* bits of precision  */
        WORD wSamplesPerBlock;          /* valid if wBitsPerSample==0 */
        WORD wReserved;                 /* If neither applies, set to zero. */
    } Samples;
    DWORD           dwChannelMask;      /* which channels are */
                                        /* present in stream  */
    GUID            SubFormat;
} WAVEFORMATEXTENSIBLE, *PWAVEFORMATEXTENSIBLE;
#endif // !_WAVEFORMATEXTENSIBLE_

#if !defined(WAVE_FORMAT_EXTENSIBLE)
#define  WAVE_FORMAT_EXTENSIBLE                 0xFFFE
#endif // !defined(WAVE_FORMAT_EXTENSIBLE)

// DirectSound buffer description
typedef struct {
    ULONG               Flags;
    ULONG               Control;
    WAVEFORMATEX        WaveFormatEx;
} CSDSOUND_BUFFERDESC, *PCSDSOUND_BUFFERDESC;

// DirectSound format
typedef struct {
    CSDATAFORMAT        DataFormat;
    CSDSOUND_BUFFERDESC BufferDesc;
} CSDATAFORMAT_DSOUND, *PCSDATAFORMAT_DSOUND;

#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <poppack.h>
#endif
#endif // defined(_INC_MMSYSTEM) || defined(_INC_MMREG)



// DirectSound buffer flags
#define CSDSOUND_BUFFER_PRIMARY             0x00000001
#define CSDSOUND_BUFFER_STATIC              0x00000002
#define CSDSOUND_BUFFER_LOCHARDWARE         0x00000004
#define CSDSOUND_BUFFER_LOCSOFTWARE         0x00000008

// DirectSound buffer control flags
#define CSDSOUND_BUFFER_CTRL_3D             0x00000001
#define CSDSOUND_BUFFER_CTRL_FREQUENCY      0x00000002
#define CSDSOUND_BUFFER_CTRL_PAN            0x00000004
#define CSDSOUND_BUFFER_CTRL_VOLUME         0x00000008
#define CSDSOUND_BUFFER_CTRL_POSITIONNOTIFY 0x00000010

typedef struct {
#if defined(_NTDDK_)
    ULONGLONG        PlayOffset;
    ULONGLONG        WriteOffset;
#else // !_NTDDK_
    DWORDLONG        PlayOffset;
    DWORDLONG        WriteOffset;
#endif // !_NTDDK_
} CSAUDIO_POSITION, *PCSAUDIO_POSITION;

//===========================================================================
// DirectSound3D HAL


typedef struct _DS3DVECTOR {
    union {
        FLOAT x;
        FLOAT dvX;
    };
    union {
        FLOAT y;
        FLOAT dvY;
    };
    union {
        FLOAT z;
        FLOAT dvZ;
    };
} DS3DVECTOR, *PDS3DVECTOR;


//===========================================================================
//===========================================================================

// CSPROPSETID_DirectSound3DListener : {437B3414-D060-11d0-8583-00C04FD9BAF3}

#define STATIC_CSPROPSETID_DirectSound3DListener\
    0x437b3414L, 0xd060, 0x11d0, 0x85, 0x83, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("437b3414-d060-11d0-8583-00c04fd9baf3",CSPROPSETID_DirectSound3DListener);
#define CSPROPSETID_DirectSound3DListener DEFINE_GUIDNAMED(CSPROPSETID_DirectSound3DListener)

typedef enum {
    CSPROPERTY_DIRECTSOUND3DLISTENER_ALL,
    CSPROPERTY_DIRECTSOUND3DLISTENER_POSITION,
    CSPROPERTY_DIRECTSOUND3DLISTENER_VELOCITY,
    CSPROPERTY_DIRECTSOUND3DLISTENER_ORIENTATION,
    CSPROPERTY_DIRECTSOUND3DLISTENER_DISTANCEFACTOR,
    CSPROPERTY_DIRECTSOUND3DLISTENER_ROLLOFFFACTOR,
    CSPROPERTY_DIRECTSOUND3DLISTENER_DOPPLERFACTOR,
    CSPROPERTY_DIRECTSOUND3DLISTENER_BATCH,
    CSPROPERTY_DIRECTSOUND3DLISTENER_ALLOCATION
} CSPROPERTY_DIRECTSOUND3DLISTENER;

typedef struct {
    DS3DVECTOR  Position;
    DS3DVECTOR  Velocity;
    DS3DVECTOR  OrientFront;
    DS3DVECTOR  OrientTop;
    FLOAT       DistanceFactor;
    FLOAT       RolloffFactor;
    FLOAT       DopplerFactor;
} CSDS3D_LISTENER_ALL, *PCSDS3D_LISTENER_ALL;

typedef struct {
    DS3DVECTOR  Front;
    DS3DVECTOR  Top;
} CSDS3D_LISTENER_ORIENTATION, *PCSDS3D_LISTENER_ORIENTATION;


//===========================================================================
//===========================================================================
// CSPROPSETID_DirectSound3DBuffer : {437B3411-D060-11d0-8583-00C04FD9BAF3}

#define STATIC_CSPROPSETID_DirectSound3DBuffer\
    0x437b3411L, 0xd060, 0x11d0, 0x85, 0x83, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("437b3411-d060-11d0-8583-00c04fd9baf3", CSPROPSETID_DirectSound3DBuffer);
#define CSPROPSETID_DirectSound3DBuffer DEFINE_GUIDNAMED(CSPROPSETID_DirectSound3DBuffer)


typedef enum {
    CSPROPERTY_DIRECTSOUND3DBUFFER_ALL,
    CSPROPERTY_DIRECTSOUND3DBUFFER_POSITION,
    CSPROPERTY_DIRECTSOUND3DBUFFER_VELOCITY,
    CSPROPERTY_DIRECTSOUND3DBUFFER_CONEANGLES,
    CSPROPERTY_DIRECTSOUND3DBUFFER_CONEORIENTATION,
    CSPROPERTY_DIRECTSOUND3DBUFFER_CONEOUTSIDEVOLUME,
    CSPROPERTY_DIRECTSOUND3DBUFFER_MINDISTANCE,
    CSPROPERTY_DIRECTSOUND3DBUFFER_MAXDISTANCE,
    CSPROPERTY_DIRECTSOUND3DBUFFER_MODE
} CSPROPERTY_DIRECTSOUND3DBUFFER;


typedef struct {
    DS3DVECTOR  Position;
    DS3DVECTOR  Velocity;
    ULONG       InsideConeAngle;
    ULONG       OutsideConeAngle;
    DS3DVECTOR  ConeOrientation;
    LONG        ConeOutsideVolume;
    FLOAT       MinDistance;
    FLOAT       MaxDistance;
    ULONG       Mode;
} CSDS3D_BUFFER_ALL, *PCSDS3D_BUFFER_ALL;

typedef struct {
    ULONG  InsideConeAngle;
    ULONG  OutsideConeAngle;
} CSDS3D_BUFFER_CONE_ANGLES, *PCSDS3D_BUFFER_CONE_ANGLES;

#define CSAUDIO_STEREO_SPEAKER_GEOMETRY_HEADPHONE   (-1)
#define CSAUDIO_STEREO_SPEAKER_GEOMETRY_MIN         5
#define CSAUDIO_STEREO_SPEAKER_GEOMETRY_NARROW      10
#define CSAUDIO_STEREO_SPEAKER_GEOMETRY_WIDE        20
#define CSAUDIO_STEREO_SPEAKER_GEOMETRY_MAX         180

#define CSDSOUND_3D_MODE_NORMAL          0x00000000
#define CSDSOUND_3D_MODE_HEADRELATIVE    0x00000001
#define CSDSOUND_3D_MODE_DISABLE         0x00000002

//===========================================================================
// Definitions intended for hardware acceleration of the HRTF 3D algorithm
//===========================================================================

#define CSDSOUND_BUFFER_CTRL_HRTF_3D        0x40000000

typedef struct {
    ULONG                   Size;           // This is the size of the struct in bytes
    ULONG                   Enabled;
    BOOL                    SwapChannels;
    BOOL                    ZeroAzimuth;
    BOOL                    CrossFadeOutput;
    ULONG                   FilterSize;     // This is the additional size of the filter coeff in bytes
} CSDS3D_HRTF_PARAMS_MSG, *PCSDS3D_HRTF_PARAMS_MSG;

// HRTF filter quality levels
typedef enum {
    FULL_FILTER,
    LIGHT_FILTER,
    CSDS3D_FILTER_QUALITY_COUNT
} CSDS3D_HRTF_FILTER_QUALITY;

typedef struct {
    ULONG                       Size;       // This is the size of the struct in bytes
    CSDS3D_HRTF_FILTER_QUALITY  Quality;
    FLOAT                       SampleRate;
    ULONG                       MaxFilterSize;
    ULONG                       FilterTransientMuteLength;
    ULONG                       FilterOverlapBufferLength;
    ULONG                       OutputOverlapBufferLength;
    ULONG                       Reserved;
} CSDS3D_HRTF_INIT_MSG, *PCSDS3D_HRTF_INIT_MSG;

// Coefficient formats
typedef enum {
    FLOAT_COEFF,
    SHORT_COEFF,
    CSDS3D_COEFF_COUNT
} CSDS3D_HRTF_COEFF_FORMAT;

// Filter methods
typedef enum {
    DIRECT_FORM,
    CASCADE_FORM,
    CSDS3D_FILTER_METHOD_COUNT
} CSDS3D_HRTF_FILTER_METHOD;

// Filter methods
typedef enum {
    DS3D_HRTF_VERSION_1
} CSDS3D_HRTF_FILTER_VERSION;

typedef struct {
    CSDS3D_HRTF_FILTER_METHOD    FilterMethod;
    CSDS3D_HRTF_COEFF_FORMAT     CoeffFormat;
    CSDS3D_HRTF_FILTER_VERSION   Version;
    ULONG                        Reserved;
} CSDS3D_HRTF_FILTER_FORMAT_MSG, *PCSDS3D_HRTF_FILTER_FORMAT_MSG;

#define STATIC_CSPROPSETID_Hrtf3d\
    0xb66decb0L, 0xa083, 0x11d0, 0x85, 0x1e, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("b66decb0-a083-11d0-851e-00c04fd9baf3", CSPROPSETID_Hrtf3d);
#define CSPROPSETID_Hrtf3d DEFINE_GUIDNAMED(CSPROPSETID_Hrtf3d)

typedef enum {
    CSPROPERTY_HRTF3D_PARAMS = 0,
    CSPROPERTY_HRTF3D_INITIALIZE,
    CSPROPERTY_HRTF3D_FILTER_FORMAT
} CSPROPERTY_HRTF3D;


//===========================================================================
// Definitions related to the obsolete Interaural Time Delay 3D algorithm
//===========================================================================

// DirectSound3D FIR context
typedef struct {
    LONG                Channel;
    FLOAT               VolSmoothScale;
    FLOAT               TotalDryAttenuation;
    FLOAT               TotalWetAttenuation;
    LONG                SmoothFrequency;
    LONG                Delay;
} CSDS3D_ITD_PARAMS, *PCSDS3D_ITD_PARAMS;

typedef struct {
    ULONG                 Enabled;
    CSDS3D_ITD_PARAMS     LeftParams;
    CSDS3D_ITD_PARAMS     RightParams;
    ULONG                 Reserved;
} CSDS3D_ITD_PARAMS_MSG, *PCSDS3D_ITD_PARAMS_MSG;

#define STATIC_CSPROPSETID_Itd3d\
    0x6429f090L, 0x9fd9, 0x11d0, 0xa7, 0x5b, 0x00, 0xa0, 0xc9, 0x03, 0x65, 0xe3
DEFINE_GUIDSTRUCT("6429f090-9fd9-11d0-a75b-00a0c90365e3", CSPROPSETID_Itd3d);
#define CSPROPSETID_Itd3d DEFINE_GUIDNAMED(CSPROPSETID_Itd3d)

typedef enum {
    CSPROPERTY_ITD3D_PARAMS = 0
} CSPROPERTY_ITD3D;


typedef struct {
   CSDATARANGE              DataRange;
   ULONG                    MaximumChannels;
   ULONG                    MinimumBitsPerSample;
   ULONG                    MaximumBitsPerSample;
   ULONG                    MinimumSampleFrequency;
   ULONG                    MaximumSampleFrequency;
} CSDATARANGE_AUDIO, *PCSDATARANGE_AUDIO;

//---------------------------------------------------------------------------

#define STATIC_CSDATAFORMAT_SUBTYPE_RIFF\
    0x4995DAEEL, 0x9EE6, 0x11D0, 0xA4, 0x0E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("4995DAEE-9EE6-11D0-A40E-00A0C9223196", CSDATAFORMAT_SUBTYPE_RIFF);
#define CSDATAFORMAT_SUBTYPE_RIFF DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_RIFF)

#define STATIC_CSDATAFORMAT_SUBTYPE_RIFFWAVE\
    0xe436eb8bL, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb8b-524f-11ce-9f53-0020af0ba770", CSDATAFORMAT_SUBTYPE_RIFFWAVE);
#define CSDATAFORMAT_SUBTYPE_RIFFWAVE DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_RIFFWAVE)

//===========================================================================
//===========================================================================

#define STATIC_CSPROPSETID_Bibliographic \
    0x07BA150EL, 0xE2B1, 0x11D0, 0xAC, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("07BA150E-E2B1-11D0-AC17-00A0C9223196", CSPROPSETID_Bibliographic);
#define CSPROPSETID_Bibliographic DEFINE_GUIDNAMED(CSPROPSETID_Bibliographic)

//Repeatable tags contain all entries within the property, each preceeded by length
typedef enum {
    CSPROPERTY_BIBLIOGRAPHIC_LEADER = 'RDL ',
    CSPROPERTY_BIBLIOGRAPHIC_LCCN = '010 ',
    CSPROPERTY_BIBLIOGRAPHIC_ISBN = '020 ',
    CSPROPERTY_BIBLIOGRAPHIC_ISSN = '220 ',
    CSPROPERTY_BIBLIOGRAPHIC_CATALOGINGSOURCE = '040 ',
    CSPROPERTY_BIBLIOGRAPHIC_MAINPERSONALNAME = '001 ',
    CSPROPERTY_BIBLIOGRAPHIC_MAINCORPORATEBODY = '011 ',
    CSPROPERTY_BIBLIOGRAPHIC_MAINMEETINGNAME = '111 ',
    CSPROPERTY_BIBLIOGRAPHIC_MAINUNIFORMTITLE = '031 ',
    CSPROPERTY_BIBLIOGRAPHIC_UNIFORMTITLE = '042 ',
    CSPROPERTY_BIBLIOGRAPHIC_TITLESTATEMENT = '542 ',
    CSPROPERTY_BIBLIOGRAPHIC_VARYINGFORMTITLE = '642 ',
    CSPROPERTY_BIBLIOGRAPHIC_PUBLICATION = '062 ',
    CSPROPERTY_BIBLIOGRAPHIC_PHYSICALDESCRIPTION = '003 ',
    CSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTITLE = '044 ',
    CSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENT = '094 ',
    CSPROPERTY_BIBLIOGRAPHIC_GENERALNOTE = '005 ',
    CSPROPERTY_BIBLIOGRAPHIC_BIBLIOGRAPHYNOTE = '405 ',
    CSPROPERTY_BIBLIOGRAPHIC_CONTENTSNOTE = '505 ',
    CSPROPERTY_BIBLIOGRAPHIC_CREATIONCREDIT = '805 ',
    CSPROPERTY_BIBLIOGRAPHIC_CITATION = '015 ',
    CSPROPERTY_BIBLIOGRAPHIC_PARTICIPANT = '115 ',
    CSPROPERTY_BIBLIOGRAPHIC_SUMMARY = '025 ',
    CSPROPERTY_BIBLIOGRAPHIC_TARGETAUDIENCE = '125 ',
    CSPROPERTY_BIBLIOGRAPHIC_ADDEDFORMAVAILABLE = '035 ',
    CSPROPERTY_BIBLIOGRAPHIC_SYSTEMDETAILS = '835 ',
    CSPROPERTY_BIBLIOGRAPHIC_AWARDS = '685 ',
    CSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYPERSONALNAME = '006 ',
    CSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTOPICALTERM = '056 ',
    CSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYGEOGRAPHIC = '156 ',
    CSPROPERTY_BIBLIOGRAPHIC_INDEXTERMGENRE = '556 ',
    CSPROPERTY_BIBLIOGRAPHIC_INDEXTERMCURRICULUM = '856 ',
    CSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYUNIFORMTITLE = '037 ',
    CSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYRELATED = '047 ',
    CSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTPERSONALNAME = '008 ',
    CSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTUNIFORMTITLE = '038 '
} CSPROPERTY_BIBLIOGRAPHIC;

#define STATIC_CSPROPSETID_TopologyNode\
    0x45FFAAA1L, 0x6E1B, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("45FFAAA1-6E1B-11D0-BCF2-444553540000", CSPROPSETID_TopologyNode);
#define CSPROPSETID_TopologyNode DEFINE_GUIDNAMED(CSPROPSETID_TopologyNode)

typedef enum {
    CSPROPERTY_TOPOLOGYNODE_ENABLE = 1,
    CSPROPERTY_TOPOLOGYNODE_RESET
} CSPROPERTY_TOPOLOGYNODE;

//===========================================================================

#if defined(_NTDDK_)
typedef NTSTATUS (CALLBACK *PRTAUDIOGETPOSITION)(IN PFILE_OBJECT PinFileObject,
                                                 OUT PUCHAR *ppPlayPosition,
                                                 OUT PLONG plOffset);
#endif // defined(_NTDDK_)

#define STATIC_CSPROPSETID_RtAudio\
    0xa855a48c, 0x2f78, 0x4729, 0x90, 0x51, 0x19, 0x68, 0x74, 0x6b, 0x9e, 0xef
DEFINE_GUIDSTRUCT("A855A48C-2F78-4729-9051-1968746B9EEF", CSPROPSETID_RtAudio);
#define CSPROPSETID_RtAudio DEFINE_GUIDNAMED(CSPROPSETID_RtAudio)

typedef enum {
    CSPROPERTY_RTAUDIO_GETPOSITIONFUNCTION,
    CSPROPERTY_RTAUDIO_BUFFER
} CSPROPERTY_RTAUDIO;

typedef struct {
    PVOID   BaseAddress;
    ULONG   Size;
} RTAUDIO_BUFFER, *PRTAUDIO_BUFFER;

//===========================================================================
#define STATIC_CSPROPSETID_DrmAudioStream\
    0x2f2c8ddd, 0x4198, 0x4fac, 0xba, 0x29, 0x61, 0xbb, 0x5, 0xb7, 0xde, 0x6
DEFINE_GUIDSTRUCT("2F2C8DDD-4198-4fac-BA29-61BB05B7DE06", CSPROPSETID_DrmAudioStream);
#define CSPROPSETID_DrmAudioStream DEFINE_GUIDNAMED(CSPROPSETID_DrmAudioStream)

typedef enum {
    CSPROPERTY_DRMAUDIOSTREAM_CONTENTID
} CSPROPERTY_DRMAUDIOSTREAM;

//===========================================================================
#define STATIC_CSPROPSETID_Audio\
    0x45FFAAA0L, 0x6E1B, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("45FFAAA0-6E1B-11D0-BCF2-444553540000", CSPROPSETID_Audio);
#define CSPROPSETID_Audio DEFINE_GUIDNAMED(CSPROPSETID_Audio)

typedef enum {
    CSPROPERTY_AUDIO_LATENCY = 1,
    CSPROPERTY_AUDIO_COPY_PROTECTION,
    CSPROPERTY_AUDIO_CHANNEL_CONFIG,
    CSPROPERTY_AUDIO_VOLUMELEVEL,
    CSPROPERTY_AUDIO_POSITION,
    CSPROPERTY_AUDIO_DYNAMIC_RANGE,
    CSPROPERTY_AUDIO_QUALITY,
    CSPROPERTY_AUDIO_SAMPLING_RATE,
    CSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE,
    CSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
    CSPROPERTY_AUDIO_MIX_LEVEL_CAPS,
    CSPROPERTY_AUDIO_MUX_SOURCE,
    CSPROPERTY_AUDIO_MUTE,
    CSPROPERTY_AUDIO_BASS,
    CSPROPERTY_AUDIO_MID,
    CSPROPERTY_AUDIO_TREBLE,
    CSPROPERTY_AUDIO_BASS_BOOST,
    CSPROPERTY_AUDIO_EQ_LEVEL,
    CSPROPERTY_AUDIO_NUM_EQ_BANDS,
    CSPROPERTY_AUDIO_EQ_BANDS,
    CSPROPERTY_AUDIO_AGC,
    CSPROPERTY_AUDIO_DELAY,
    CSPROPERTY_AUDIO_LOUDNESS,
    CSPROPERTY_AUDIO_WIDE_MODE,
    CSPROPERTY_AUDIO_WIDENESS,
    CSPROPERTY_AUDIO_REVERB_LEVEL,
    CSPROPERTY_AUDIO_CHORUS_LEVEL,
    CSPROPERTY_AUDIO_DEV_SPECIFIC,
    CSPROPERTY_AUDIO_DEMUX_DEST,
    CSPROPERTY_AUDIO_STEREO_ENHANCE,
    CSPROPERTY_AUDIO_MANUFACTURE_GUID,
    CSPROPERTY_AUDIO_PRODUCT_GUID,
    CSPROPERTY_AUDIO_CPU_RESOURCES,
    CSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY,
    CSPROPERTY_AUDIO_SURROUND_ENCODE,
    CSPROPERTY_AUDIO_3D_INTERFACE,
    CSPROPERTY_AUDIO_PEAKMETER,
    CSPROPERTY_AUDIO_ALGORITHM_INSTANCE,
    CSPROPERTY_AUDIO_FILTER_STATE,
    CSPROPERTY_AUDIO_PREFERRED_STATUS,
    CSPROPERTY_AUDIO_PEQ_MAX_BANDS,
    CSPROPERTY_AUDIO_PEQ_NUM_BANDS,
    CSPROPERTY_AUDIO_PEQ_BAND_CENTER_FREQ,
    CSPROPERTY_AUDIO_PEQ_BAND_Q_FACTOR,
    CSPROPERTY_AUDIO_PEQ_BAND_LEVEL,
    CSPROPERTY_AUDIO_CHORUS_MODULATION_RATE,
    CSPROPERTY_AUDIO_CHORUS_MODULATION_DEPTH,
    CSPROPERTY_AUDIO_REVERB_TIME,
    CSPROPERTY_AUDIO_REVERB_DELAY_FEEDBACK
} CSPROPERTY_AUDIO;

// Audio quality constants
#define CSAUDIO_QUALITY_WORST               0x0
#define CSAUDIO_QUALITY_PC                  0x1
#define CSAUDIO_QUALITY_BASIC               0x2
#define CSAUDIO_QUALITY_ADVANCED            0x3

// Audio CPU resource constants
#define CSAUDIO_CPU_RESOURCES_NOT_HOST_CPU  0x00000000
#define CSAUDIO_CPU_RESOURCES_HOST_CPU      0x7FFFFFFF

typedef struct {
    BOOL    fCopyrighted;
    BOOL    fOriginal;
} CSAUDIO_COPY_PROTECTION, *PCSAUDIO_COPY_PROTECTION;

typedef struct {
    LONG    ActiveSpeakerPositions;
} CSAUDIO_CHANNEL_CONFIG, *PCSAUDIO_CHANNEL_CONFIG;

// Speaker Positions:
#define SPEAKER_FRONT_LEFT              0x1
#define SPEAKER_FRONT_RIGHT             0x2
#define SPEAKER_FRONT_CENTER            0x4
#define SPEAKER_LOW_FREQUENCY           0x8
#define SPEAKER_BACK_LEFT               0x10
#define SPEAKER_BACK_RIGHT              0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER    0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER   0x80
#define SPEAKER_BACK_CENTER             0x100
#define SPEAKER_SIDE_LEFT               0x200
#define SPEAKER_SIDE_RIGHT              0x400
#define SPEAKER_TOP_CENTER              0x800
#define SPEAKER_TOP_FRONT_LEFT          0x1000
#define SPEAKER_TOP_FRONT_CENTER        0x2000
#define SPEAKER_TOP_FRONT_RIGHT         0x4000
#define SPEAKER_TOP_BACK_LEFT           0x8000
#define SPEAKER_TOP_BACK_CENTER         0x10000
#define SPEAKER_TOP_BACK_RIGHT          0x20000

// Bit mask locations reserved for future use
#define SPEAKER_RESERVED                0x7FFC0000

// Used to specify that any possible permutation of speaker configurations
#define SPEAKER_ALL                     0x80000000

// DirectSound Speaker Config
#define CSAUDIO_SPEAKER_DIRECTOUT       0
#define CSAUDIO_SPEAKER_MONO            (SPEAKER_FRONT_CENTER)
#define CSAUDIO_SPEAKER_STEREO          (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT)
#define CSAUDIO_SPEAKER_QUAD            (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_BACK_LEFT  | SPEAKER_BACK_RIGHT)
#define CSAUDIO_SPEAKER_SURROUND        (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_BACK_CENTER)
#define CSAUDIO_SPEAKER_5POINT1         (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | \
                                         SPEAKER_BACK_LEFT  | SPEAKER_BACK_RIGHT)
#define CSAUDIO_SPEAKER_7POINT1         (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | \
                                         SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT | \
                                         SPEAKER_FRONT_LEFT_OF_CENTER | SPEAKER_FRONT_RIGHT_OF_CENTER)

// DVD Speaker Positions
#define CSAUDIO_SPEAKER_GROUND_FRONT_LEFT   SPEAKER_FRONT_LEFT
#define CSAUDIO_SPEAKER_GROUND_FRONT_CENTER SPEAKER_FRONT_CENTER
#define CSAUDIO_SPEAKER_GROUND_FRONT_RIGHT  SPEAKER_FRONT_RIGHT
#define CSAUDIO_SPEAKER_GROUND_REAR_LEFT    SPEAKER_BACK_LEFT
#define CSAUDIO_SPEAKER_GROUND_REAR_RIGHT   SPEAKER_BACK_RIGHT
#define CSAUDIO_SPEAKER_TOP_MIDDLE          SPEAKER_TOP_CENTER
#define CSAUDIO_SPEAKER_SUPER_WOOFER        SPEAKER_LOW_FREQUENCY

typedef struct {
    ULONG   QuietCompression;
    ULONG   LoudCompression;
} CSAUDIO_DYNAMIC_RANGE, *PCSAUDIO_DYNAMIC_RANGE;

typedef struct {
    BOOL    Mute;
    LONG    Level;
} CSAUDIO_MIXLEVEL, *PCSAUDIO_MIXLEVEL;

typedef struct {
    BOOL    Mute;
    LONG    Minimum;
    LONG    Maximum;
    union {
        LONG    Reset;
        LONG    Resolution;
    };
} CSAUDIO_MIX_CAPS, *PCSAUDIO_MIX_CAPS;

typedef struct {
    ULONG               InputChannels;
    ULONG               OutputChannels;
    CSAUDIO_MIX_CAPS    Capabilities[1];
} CSAUDIO_MIXCAP_TABLE, *PCSAUDIO_MIXCAP_TABLE;

typedef enum {
    SE_TECH_NONE,
    SE_TECH_ANALOG_DEVICES_PHAT,
    SE_TECH_CREATIVE,
    SE_TECH_NATIONAL_SEMI,
    SE_TECH_YAMAHA_YMERSION,
    SE_TECH_BBE,
    SE_TECH_CRYSTAL_SEMI,
    SE_TECH_QSOUND_QXPANDER,
    SE_TECH_SPATIALIZER,
    SE_TECH_SRS,
    SE_TECH_PLATFORM_TECH,
    SE_TECH_AKM,
    SE_TECH_AUREAL,
    SE_TECH_AZTECH,
    SE_TECH_BINAURA,
    SE_TECH_ESS_TECH,
    SE_TECH_HARMAN_VMAX,
    SE_TECH_NVIDEA,
    SE_TECH_PHILIPS_INCREDIBLE,
    SE_TECH_TEXAS_INST,
    SE_TECH_VLSI_TECH
} SE_TECHNIQUE;

typedef struct {
    SE_TECHNIQUE    Technique;
    ULONG   Center;
    ULONG   Depth;
    ULONG   Reserved;
} CSAUDIO_STEREO_ENHANCE, *PCSAUDIO_STEREO_ENHANCE;

typedef enum {              // preferred device index
    CSPROPERTY_SYSAUDIO_NORMAL_DEFAULT = 0,
    CSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT,
    CSPROPERTY_SYSAUDIO_RECORD_DEFAULT,
    CSPROPERTY_SYSAUDIO_MIDI_DEFAULT,
    CSPROPERTY_SYSAUDIO_MIXER_DEFAULT
} CSPROPERTY_SYSAUDIO_DEFAULT_TYPE;

typedef struct {
    BOOL                             Enable;
    CSPROPERTY_SYSAUDIO_DEFAULT_TYPE DeviceType;
    ULONG                            Flags;
    ULONG                            Reserved;
} CSAUDIO_PREFERRED_STATUS, *PCSAUDIO_PREFERRED_STATUS;
//===========================================================================
// Topology Node Type GUIDs

#define STATIC_CSNODETYPE_DAC\
    0x507AE360L, 0xC554, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("507AE360-C554-11D0-8A2B-00A0C9255AC1", CSNODETYPE_DAC);
#define CSNODETYPE_DAC DEFINE_GUIDNAMED(CSNODETYPE_DAC)

#define STATIC_CSNODETYPE_ADC\
    0x4D837FE0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("4D837FE0-C555-11D0-8A2B-00A0C9255AC1", CSNODETYPE_ADC);
#define CSNODETYPE_ADC DEFINE_GUIDNAMED(CSNODETYPE_ADC)

#define STATIC_CSNODETYPE_SRC\
    0x9DB7B9E0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("9DB7B9E0-C555-11D0-8A2B-00A0C9255AC1", CSNODETYPE_SRC);
#define CSNODETYPE_SRC DEFINE_GUIDNAMED(CSNODETYPE_SRC)

#define STATIC_CSNODETYPE_SUPERMIX\
    0xE573ADC0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("E573ADC0-C555-11D0-8A2B-00A0C9255AC1", CSNODETYPE_SUPERMIX);
#define CSNODETYPE_SUPERMIX DEFINE_GUIDNAMED(CSNODETYPE_SUPERMIX)

#define STATIC_CSNODETYPE_MUX\
    0x2CEAF780L, 0xC556, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("2CEAF780-C556-11D0-8A2B-00A0C9255AC1", CSNODETYPE_MUX);
#define CSNODETYPE_MUX DEFINE_GUIDNAMED(CSNODETYPE_MUX)

#define STATIC_CSNODETYPE_DEMUX\
    0xC0EB67D4L, 0xE807, 0x11D0, 0x95, 0x8A, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("C0EB67D4-E807-11D0-958A-00C04FB925D3", CSNODETYPE_DEMUX);
#define CSNODETYPE_DEMUX DEFINE_GUIDNAMED(CSNODETYPE_DEMUX)

#define STATIC_CSNODETYPE_SUM\
    0xDA441A60L, 0xC556, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("DA441A60-C556-11D0-8A2B-00A0C9255AC1", CSNODETYPE_SUM);
#define CSNODETYPE_SUM DEFINE_GUIDNAMED(CSNODETYPE_SUM)

#define STATIC_CSNODETYPE_MUTE\
    0x02B223C0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("02B223C0-C557-11D0-8A2B-00A0C9255AC1", CSNODETYPE_MUTE);
#define CSNODETYPE_MUTE DEFINE_GUIDNAMED(CSNODETYPE_MUTE)

#define STATIC_CSNODETYPE_VOLUME\
    0x3A5ACC00L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("3A5ACC00-C557-11D0-8A2B-00A0C9255AC1", CSNODETYPE_VOLUME);
#define CSNODETYPE_VOLUME DEFINE_GUIDNAMED(CSNODETYPE_VOLUME)

#define STATIC_CSNODETYPE_TONE\
    0x7607E580L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("7607E580-C557-11D0-8A2B-00A0C9255AC1", CSNODETYPE_TONE);
#define CSNODETYPE_TONE DEFINE_GUIDNAMED(CSNODETYPE_TONE)

#define STATIC_CSNODETYPE_EQUALIZER\
    0x9D41B4A0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("9D41B4A0-C557-11D0-8A2B-00A0C9255AC1", CSNODETYPE_EQUALIZER);
#define CSNODETYPE_EQUALIZER DEFINE_GUIDNAMED(CSNODETYPE_EQUALIZER)

#define STATIC_CSNODETYPE_AGC\
    0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("E88C9BA0-C557-11D0-8A2B-00A0C9255AC1", CSNODETYPE_AGC);
#define CSNODETYPE_AGC DEFINE_GUIDNAMED(CSNODETYPE_AGC)

#define STATIC_CSNODETYPE_NOISE_SUPPRESS\
    0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5
DEFINE_GUIDSTRUCT("E07F903F-62FD-4e60-8CDD-DEA7236665B5", CSNODETYPE_NOISE_SUPPRESS);
#define CSNODETYPE_NOISE_SUPPRESS DEFINE_GUIDNAMED(CSNODETYPE_NOISE_SUPPRESS)

#define STATIC_CSNODETYPE_DELAY\
    0x144981E0L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("144981E0-C558-11D0-8A2B-00A0C9255AC1", CSNODETYPE_DELAY);
#define CSNODETYPE_DELAY DEFINE_GUIDNAMED(CSNODETYPE_DELAY)

#define STATIC_CSNODETYPE_LOUDNESS\
    0x41887440L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("41887440-C558-11D0-8A2B-00A0C9255AC1", CSNODETYPE_LOUDNESS);
#define CSNODETYPE_LOUDNESS DEFINE_GUIDNAMED(CSNODETYPE_LOUDNESS)

#define STATIC_CSNODETYPE_PROLOGIC_DECODER\
    0x831C2C80L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("831C2C80-C558-11D0-8A2B-00A0C9255AC1", CSNODETYPE_PROLOGIC_DECODER);
#define CSNODETYPE_PROLOGIC_DECODER DEFINE_GUIDNAMED(CSNODETYPE_PROLOGIC_DECODER)

#define STATIC_CSNODETYPE_STEREO_WIDE\
    0xA9E69800L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("A9E69800-C558-11D0-8A2B-00A0C9255AC1", CSNODETYPE_STEREO_WIDE);
#define CSNODETYPE_STEREO_WIDE DEFINE_GUIDNAMED(CSNODETYPE_STEREO_WIDE)

#define STATIC_CSNODETYPE_STEREO_ENHANCE\
    0xAF6878ACL, 0xE83F, 0x11D0, 0x95, 0x8A, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("AF6878AC-E83F-11D0-958A-00C04FB925D3", CSNODETYPE_STEREO_ENHANCE);
#define CSNODETYPE_STEREO_ENHANCE DEFINE_GUIDNAMED(CSNODETYPE_STEREO_ENHANCE)

#define STATIC_CSNODETYPE_REVERB\
    0xEF0328E0L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("EF0328E0-C558-11D0-8A2B-00A0C9255AC1", CSNODETYPE_REVERB);
#define CSNODETYPE_REVERB DEFINE_GUIDNAMED(CSNODETYPE_REVERB)

#define STATIC_CSNODETYPE_CHORUS\
    0x20173F20L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("20173F20-C559-11D0-8A2B-00A0C9255AC1", CSNODETYPE_CHORUS);
#define CSNODETYPE_CHORUS DEFINE_GUIDNAMED(CSNODETYPE_CHORUS)

#define STATIC_CSNODETYPE_3D_EFFECTS\
    0x55515860L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("55515860-C559-11D0-8A2B-00A0C9255AC1", CSNODETYPE_3D_EFFECTS);
#define CSNODETYPE_3D_EFFECTS DEFINE_GUIDNAMED(CSNODETYPE_3D_EFFECTS)

#define STATIC_CSNODETYPE_PARAMETRIC_EQUALIZER\
    0x19bb3a6a, 0xce2b, 0x4442, 0x87, 0xec, 0x67, 0x27, 0xc3, 0xca, 0xb4, 0x77
DEFINE_GUIDSTRUCT("19BB3A6A-CE2B-4442-87EC-6727C3CAB477", CSNODETYPE_PARAMETRIC_EQUALIZER);
#define CSNODETYPE_PARAMETRIC_EQUALIZER DEFINE_GUIDNAMED(CSNODETYPE_PARAMETRIC_EQUALIZER)

#define STATIC_CSNODETYPE_UPDOWN_MIX\
    0xb7edc5cf, 0x7b63, 0x4ee2, 0xa1, 0x0, 0x29, 0xee, 0x2c, 0xb6, 0xb2, 0xde
DEFINE_GUIDSTRUCT("B7EDC5CF-7B63-4ee2-A100-29EE2CB6B2DE", CSNODETYPE_UPDOWN_MIX);
#define CSNODETYPE_UPDOWN_MIX DEFINE_GUIDNAMED(CSNODETYPE_UPDOWN_MIX)

#define STATIC_CSNODETYPE_DYN_RANGE_COMPRESSOR\
    0x8c8a6a8, 0x601f, 0x4af8, 0x87, 0x93, 0xd9, 0x5, 0xff, 0x4c, 0xa9, 0x7d
DEFINE_GUIDSTRUCT("08C8A6A8-601F-4af8-8793-D905FF4CA97D", CSNODETYPE_DYN_RANGE_COMPRESSOR);
#define CSNODETYPE_DYN_RANGE_COMPRESSOR DEFINE_GUIDNAMED(CSNODETYPE_DYN_RANGE_COMPRESSOR)

#define STATIC_CSNODETYPE_ACOUSTIC_ECHO_CANCEL STATIC_CSCATEGORY_ACOUSTIC_ECHO_CANCEL
#define CSNODETYPE_ACOUSTIC_ECHO_CANCEL CSCATEGORY_ACOUSTIC_ECHO_CANCEL

#define STATIC_CSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL\
    0x1c22c56dL, 0x9879, 0x4f5b, 0xa3, 0x89, 0x27, 0x99, 0x6d, 0xdc, 0x28, 0x10
DEFINE_GUIDSTRUCT("1C22C56D-9879-4f5b-A389-27996DDC2810", CSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL);
#define CSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL DEFINE_GUIDNAMED(CSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL)

#define STATIC_CSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS\
    0x5ab0882eL, 0x7274, 0x4516, 0x87, 0x7d, 0x4e, 0xee, 0x99, 0xba, 0x4f, 0xd0
DEFINE_GUIDSTRUCT("5AB0882E-7274-4516-877D-4EEE99BA4FD0", CSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS);
#define CSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS DEFINE_GUIDNAMED(CSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS)

#define STATIC_CSALGORITHMINSTANCE_SYSTEM_AGC\
    0x950e55b9L, 0x877c, 0x4c67, 0xbe, 0x8, 0xe4, 0x7b, 0x56, 0x11, 0x13, 0xa
DEFINE_GUIDSTRUCT("950E55B9-877C-4c67-BE08-E47B5611130A", CSALGORITHMINSTANCE_SYSTEM_AGC);
#define CSALGORITHMINSTANCE_SYSTEM_AGC DEFINE_GUIDNAMED(CSALGORITHMINSTANCE_SYSTEM_AGC)

#define STATIC_CSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR\
    0xB6F5A0A0L, 0x9E61, 0x4F8C, 0x91, 0xE3, 0x76, 0xCF, 0xF, 0x3C, 0x47, 0x1F
DEFINE_GUIDSTRUCT("B6F5A0A0-9E61-4f8c-91E3-76CF0F3C471F", CSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR);
#define CSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR DEFINE_GUIDNAMED(CSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR)


#define STATIC_CSNODETYPE_MICROPHONE_ARRAY_PROCESSOR STATIC_CSCATEGORY_MICROPHONE_ARRAY_PROCESSOR
#define CSNODETYPE_MICROPHONE_ARRAY_PROCESSOR CSCATEGORY_MICROPHONE_ARRAY_PROCESSOR

#define STATIC_CSNODETYPE_DEV_SPECIFIC\
    0x941C7AC0L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("941C7AC0-C559-11D0-8A2B-00A0C9255AC1", CSNODETYPE_DEV_SPECIFIC);
#define CSNODETYPE_DEV_SPECIFIC DEFINE_GUIDNAMED(CSNODETYPE_DEV_SPECIFIC)

#define STATIC_CSNODETYPE_PROLOGIC_ENCODER\
    0x8074C5B2L, 0x3C66, 0x11D2, 0xB4, 0x5A, 0x30, 0x78, 0x30, 0x2C, 0x20, 0x30
DEFINE_GUIDSTRUCT("8074C5B2-3C66-11D2-B45A-3078302C2030", CSNODETYPE_PROLOGIC_ENCODER);
#define CSNODETYPE_PROLOGIC_ENCODER DEFINE_GUIDNAMED(CSNODETYPE_PROLOGIC_ENCODER)
#define CSNODETYPE_SURROUND_ENCODER CSNODETYPE_PROLOGIC_ENCODER

#define STATIC_CSNODETYPE_PEAKMETER\
    0xa085651eL, 0x5f0d, 0x4b36, 0xa8, 0x69, 0xd1, 0x95, 0xd6, 0xab, 0x4b, 0x9e
DEFINE_GUIDSTRUCT("A085651E-5F0D-4b36-A869-D195D6AB4B9E", CSNODETYPE_PEAKMETER);
#define CSNODETYPE_PEAKMETER DEFINE_GUIDNAMED(CSNODETYPE_PEAKMETER)

//===========================================================================
// Topology Node Name GUIDs for common audio nodes
#define STATIC_CSAUDFNAME_BASS\
    0x185FEDE0L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE0-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_BASS);
#define CSAUDFNAME_BASS DEFINE_GUIDNAMED(CSAUDFNAME_BASS)

#define STATIC_CSAUDFNAME_TREBLE\
    0x185FEDE1L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE1-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_TREBLE);
#define CSAUDFNAME_TREBLE DEFINE_GUIDNAMED(CSAUDFNAME_TREBLE)

#define STATIC_CSAUDFNAME_3D_STEREO\
    0x185FEDE2L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE2-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_3D_STEREO);
#define CSAUDFNAME_3D_STEREO DEFINE_GUIDNAMED(CSAUDFNAME_3D_STEREO)

#define STATIC_CSAUDFNAME_MASTER_VOLUME\
    0x185FEDE3L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE3-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MASTER_VOLUME);
#define CSAUDFNAME_MASTER_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_MASTER_VOLUME)

#define STATIC_CSAUDFNAME_MASTER_MUTE\
    0x185FEDE4L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE4-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MASTER_MUTE);
#define CSAUDFNAME_MASTER_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_MASTER_MUTE)

#define STATIC_CSAUDFNAME_WAVE_VOLUME\
    0x185FEDE5L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE5-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_WAVE_VOLUME);
#define CSAUDFNAME_WAVE_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_WAVE_VOLUME)

#define STATIC_CSAUDFNAME_WAVE_MUTE\
    0x185FEDE6L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE6-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_WAVE_MUTE);
#define CSAUDFNAME_WAVE_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_WAVE_MUTE)

#define STATIC_CSAUDFNAME_MIDI_VOLUME\
    0x185FEDE7L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE7-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MIDI_VOLUME);
#define CSAUDFNAME_MIDI_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_MIDI_VOLUME)

#define STATIC_CSAUDFNAME_MIDI_MUTE\
    0x185FEDE8L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE8-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MIDI_MUTE);
#define CSAUDFNAME_MIDI_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_MIDI_MUTE)

#define STATIC_CSAUDFNAME_CD_VOLUME\
    0x185FEDE9L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE9-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_CD_VOLUME);
#define CSAUDFNAME_CD_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_CD_VOLUME)

#define STATIC_CSAUDFNAME_CD_MUTE\
    0x185FEDEAL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEA-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_CD_MUTE);
#define CSAUDFNAME_CD_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_CD_MUTE)

#define STATIC_CSAUDFNAME_LINE_VOLUME\
    0x185FEDEBL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEB-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_LINE_VOLUME);
#define CSAUDFNAME_LINE_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_LINE_VOLUME)

#define STATIC_CSAUDFNAME_LINE_MUTE\
    0x185FEDECL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEC-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_LINE_MUTE);
#define CSAUDFNAME_LINE_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_LINE_MUTE)

#define STATIC_CSAUDFNAME_MIC_VOLUME\
    0x185FEDEDL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDED-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MIC_VOLUME);
#define CSAUDFNAME_MIC_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_MIC_VOLUME)

#define STATIC_CSAUDFNAME_MIC_MUTE\
    0x185FEDEEL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEE-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MIC_MUTE);
#define CSAUDFNAME_MIC_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_MIC_MUTE)

#define STATIC_CSAUDFNAME_RECORDING_SOURCE\
    0x185FEDEFL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEF-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_RECORDING_SOURCE);
#define CSAUDFNAME_RECORDING_SOURCE DEFINE_GUIDNAMED(CSAUDFNAME_RECORDING_SOURCE)

#define STATIC_CSAUDFNAME_PC_SPEAKER_VOLUME\
    0x185FEDF0L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF0-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_PC_SPEAKER_VOLUME);
#define CSAUDFNAME_PC_SPEAKER_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_PC_SPEAKER_VOLUME)

#define STATIC_CSAUDFNAME_PC_SPEAKER_MUTE\
    0x185FEDF1L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF1-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_PC_SPEAKER_MUTE);
#define CSAUDFNAME_PC_SPEAKER_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_PC_SPEAKER_MUTE)

#define STATIC_CSAUDFNAME_MIDI_IN_VOLUME\
    0x185FEDF2L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF2-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MIDI_IN_VOLUME);
#define CSAUDFNAME_MIDI_IN_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_MIDI_IN_VOLUME)

#define STATIC_CSAUDFNAME_CD_IN_VOLUME\
    0x185FEDF3L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF3-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_CD_IN_VOLUME);
#define CSAUDFNAME_CD_IN_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_CD_IN_VOLUME)

#define STATIC_CSAUDFNAME_LINE_IN_VOLUME\
    0x185FEDF4L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF4-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_LINE_IN_VOLUME);
#define CSAUDFNAME_LINE_IN_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_LINE_IN_VOLUME)

#define STATIC_CSAUDFNAME_MIC_IN_VOLUME\
    0x185FEDF5L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF5-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MIC_IN_VOLUME);
#define CSAUDFNAME_MIC_IN_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_MIC_IN_VOLUME)

#define STATIC_CSAUDFNAME_WAVE_IN_VOLUME\
    0x185FEDF6L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF6-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_WAVE_IN_VOLUME);
#define CSAUDFNAME_WAVE_IN_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_WAVE_IN_VOLUME)

#define STATIC_CSAUDFNAME_VOLUME_CONTROL\
    0x185FEDF7L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF7-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_VOLUME_CONTROL);
#define CSAUDFNAME_VOLUME_CONTROL DEFINE_GUIDNAMED(CSAUDFNAME_VOLUME_CONTROL)

#define STATIC_CSAUDFNAME_MIDI\
    0x185FEDF8L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF8-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_MIDI);
#define CSAUDFNAME_MIDI DEFINE_GUIDNAMED(CSAUDFNAME_MIDI)

#define STATIC_CSAUDFNAME_LINE_IN\
    0x185FEDF9L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF9-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_LINE_IN);
#define CSAUDFNAME_LINE_IN DEFINE_GUIDNAMED(CSAUDFNAME_LINE_IN)

#define STATIC_CSAUDFNAME_RECORDING_CONTROL\
    0x185FEDFAL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFA-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_RECORDING_CONTROL);
#define CSAUDFNAME_RECORDING_CONTROL DEFINE_GUIDNAMED(CSAUDFNAME_RECORDING_CONTROL)

#define STATIC_CSAUDFNAME_CD_AUDIO\
    0x185FEDFBL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFB-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_CD_AUDIO);
#define CSAUDFNAME_CD_AUDIO DEFINE_GUIDNAMED(CSAUDFNAME_CD_AUDIO)

#define STATIC_CSAUDFNAME_AUX_VOLUME\
    0x185FEDFCL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFC-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_AUX_VOLUME);
#define CSAUDFNAME_AUX_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_AUX_VOLUME)

#define STATIC_CSAUDFNAME_AUX_MUTE\
    0x185FEDFDL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFD-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_AUX_MUTE);
#define CSAUDFNAME_AUX_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_AUX_MUTE)

#define STATIC_CSAUDFNAME_AUX\
    0x185FEDFEL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFE-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_AUX);
#define CSAUDFNAME_AUX DEFINE_GUIDNAMED(CSAUDFNAME_AUX)

#define STATIC_CSAUDFNAME_PC_SPEAKER\
    0x185FEDFFL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFF-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_PC_SPEAKER);
#define CSAUDFNAME_PC_SPEAKER DEFINE_GUIDNAMED(CSAUDFNAME_PC_SPEAKER)

#define STATIC_CSAUDFNAME_WAVE_OUT_MIX\
    0x185FEE00L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEE00-9905-11D1-95A9-00C04FB925D3", CSAUDFNAME_WAVE_OUT_MIX);
#define CSAUDFNAME_WAVE_OUT_MIX DEFINE_GUIDNAMED(CSAUDFNAME_WAVE_OUT_MIX)

#define STATIC_CSAUDFNAME_MONO_OUT\
    0xf9b41dc3L, 0x96e2, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("F9B41DC3-96E2-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_MONO_OUT);
#define CSAUDFNAME_MONO_OUT DEFINE_GUIDNAMED(CSAUDFNAME_MONO_OUT)

#define STATIC_CSAUDFNAME_STEREO_MIX\
    0xdff077L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("00DFF077-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_STEREO_MIX);
#define CSAUDFNAME_STEREO_MIX DEFINE_GUIDNAMED(CSAUDFNAME_STEREO_MIX)

#define STATIC_CSAUDFNAME_MONO_MIX\
    0xdff078L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("00DFF078-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_MONO_MIX);
#define CSAUDFNAME_MONO_MIX DEFINE_GUIDNAMED(CSAUDFNAME_MONO_MIX)

#define STATIC_CSAUDFNAME_MONO_OUT_VOLUME\
    0x1ad247ebL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247EB-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_MONO_OUT_VOLUME);
#define CSAUDFNAME_MONO_OUT_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_MONO_OUT_VOLUME)

#define STATIC_CSAUDFNAME_MONO_OUT_MUTE\
    0x1ad247ecL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247EC-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_MONO_OUT_MUTE);
#define CSAUDFNAME_MONO_OUT_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_MONO_OUT_MUTE)

#define STATIC_CSAUDFNAME_STEREO_MIX_VOLUME\
    0x1ad247edL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247ED-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_STEREO_MIX_VOLUME);
#define CSAUDFNAME_STEREO_MIX_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_STEREO_MIX_VOLUME)

#define STATIC_CSAUDFNAME_STEREO_MIX_MUTE\
    0x22b0eafdL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("22B0EAFD-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_STEREO_MIX_MUTE);
#define CSAUDFNAME_STEREO_MIX_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_STEREO_MIX_MUTE)

#define STATIC_CSAUDFNAME_MONO_MIX_VOLUME\
    0x22b0eafeL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("22B0EAFE-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_MONO_MIX_VOLUME);
#define CSAUDFNAME_MONO_MIX_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_MONO_MIX_VOLUME)

#define STATIC_CSAUDFNAME_MONO_MIX_MUTE\
    0x2bc31d69L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D69-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_MONO_MIX_MUTE);
#define CSAUDFNAME_MONO_MIX_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_MONO_MIX_MUTE)

#define STATIC_CSAUDFNAME_MICROPHONE_BOOST\
    0x2bc31d6aL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D6A-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_MICROPHONE_BOOST);
#define CSAUDFNAME_MICROPHONE_BOOST DEFINE_GUIDNAMED(CSAUDFNAME_MICROPHONE_BOOST)

#define STATIC_CSAUDFNAME_ALTERNATE_MICROPHONE\
    0x2bc31d6bL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D6B-96E3-11d2-AC4C-00C04F8EFB68", CSAUDFNAME_ALTERNATE_MICROPHONE);
#define CSAUDFNAME_ALTERNATE_MICROPHONE DEFINE_GUIDNAMED(CSAUDFNAME_ALTERNATE_MICROPHONE)

#define STATIC_CSAUDFNAME_3D_DEPTH\
    0x63ff5747L, 0x991f, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("63FF5747-991F-11d2-AC4D-00C04F8EFB68", CSAUDFNAME_3D_DEPTH);
#define CSAUDFNAME_3D_DEPTH DEFINE_GUIDNAMED(CSAUDFNAME_3D_DEPTH)

#define STATIC_CSAUDFNAME_3D_CENTER\
    0x9f0670b4L, 0x991f, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9F0670B4-991F-11d2-AC4D-00C04F8EFB68", CSAUDFNAME_3D_CENTER);
#define CSAUDFNAME_3D_CENTER DEFINE_GUIDNAMED(CSAUDFNAME_3D_CENTER)

#define STATIC_CSAUDFNAME_VIDEO_VOLUME\
    0x9b46e708L, 0x992a, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9B46E708-992A-11d2-AC4D-00C04F8EFB68", CSAUDFNAME_VIDEO_VOLUME);
#define CSAUDFNAME_VIDEO_VOLUME DEFINE_GUIDNAMED(CSAUDFNAME_VIDEO_VOLUME)

#define STATIC_CSAUDFNAME_VIDEO_MUTE\
    0x9b46e709L, 0x992a, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9B46E709-992A-11d2-AC4D-00C04F8EFB68", CSAUDFNAME_VIDEO_MUTE);
#define CSAUDFNAME_VIDEO_MUTE DEFINE_GUIDNAMED(CSAUDFNAME_VIDEO_MUTE)

#define STATIC_CSAUDFNAME_VIDEO\
    0x915daec4L, 0xa434, 0x11d2, 0xac, 0x52, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("915DAEC4-A434-11d2-AC52-00C04F8EFB68", CSAUDFNAME_VIDEO);
#define CSAUDFNAME_VIDEO DEFINE_GUIDNAMED(CSAUDFNAME_VIDEO)

#define STATIC_CSAUDFNAME_PEAKMETER\
    0x57e24340L, 0xfc5b, 0x4612, 0xa5, 0x62, 0x72, 0xb1, 0x1a, 0x29, 0xdf, 0xae
DEFINE_GUIDSTRUCT("57E24340-FC5B-4612-A562-72B11A29DFAE", CSAUDFNAME_PEAKMETER);
#define CSAUDFNAME_PEAKMETER DEFINE_GUIDNAMED(CSAUDFNAME_PEAKMETER)

// Internal topology node pin definitions

#define CSNODEPIN_STANDARD_IN       1
#define CSNODEPIN_STANDARD_OUT      0

#define CSNODEPIN_SUM_MUX_IN        1   // can be >= 1
#define CSNODEPIN_SUM_MUX_OUT       0

#define CSNODEPIN_DEMUX_IN          0
#define CSNODEPIN_DEMUX_OUT         1   // can be >= 1

#define CSNODEPIN_AEC_RENDER_IN     1
#define CSNODEPIN_AEC_RENDER_OUT    0
#define CSNODEPIN_AEC_CAPTURE_IN    2
#define CSNODEPIN_AEC_CAPTURE_OUT   3

//===========================================================================
//===========================================================================

#define STATIC_CSMETHODSETID_Wavetable\
    0xDCEF31EBL, 0xD907, 0x11D0, 0x95, 0x83, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("DCEF31EB-D907-11D0-9583-00C04FB925D3", CSMETHODSETID_Wavetable);
#define CSMETHODSETID_Wavetable DEFINE_GUIDNAMED(CSMETHODSETID_Wavetable)

typedef enum {
    CSMETHOD_WAVETABLE_WAVE_ALLOC,
    CSMETHOD_WAVETABLE_WAVE_FREE,
    CSMETHOD_WAVETABLE_WAVE_FIND,
    CSMETHOD_WAVETABLE_WAVE_WRITE
} CSMETHOD_WAVETABLE;

typedef struct {
    CSIDENTIFIER        Identifier;                     // wave identifier
    ULONG               Size;                           // wave size
    BOOL                Looped;                         // wave looped flag
    ULONG               LoopPoint;                      // wave loop point
    BOOL                InROM;                          // wave InROM flag
    CSDATAFORMAT        Format;                         // wave format
} CSWAVETABLE_WAVE_DESC, *PCSWAVETABLE_WAVE_DESC;


//===========================================================================
//===========================================================================

/*
    Property sets and items
*/

//===========================================================================
//===========================================================================

#define STATIC_CSPROPSETID_Acoustic_Echo_Cancel\
    0xd7a4af8bL, 0x3dc1, 0x4902, 0x91, 0xea, 0x8a, 0x15, 0xc9, 0x0e, 0x05, 0xb2
DEFINE_GUIDSTRUCT("D7A4AF8B-3DC1-4902-91EA-8A15C90E05B2", CSPROPSETID_Acoustic_Echo_Cancel);
#define CSPROPSETID_Acoustic_Echo_Cancel DEFINE_GUIDNAMED(CSPROPSETID_Acoustic_Echo_Cancel)

typedef enum {
    CSPROPERTY_AEC_NOISE_FILL_ENABLE = 0,
    CSPROPERTY_AEC_STATUS,
    CSPROPERTY_AEC_MODE
} CSPROPERTY_AEC;

#define AEC_STATUS_FD_HISTORY_UNINITIALIZED             0x0
#define AEC_STATUS_FD_HISTORY_CONTINUOUSLY_CONVERGED    0x1
#define AEC_STATUS_FD_HISTORY_PREVIOUSLY_DIVERGED       0x2
#define AEC_STATUS_FD_CURRENTLY_CONVERGED               0x8

#define AEC_MODE_PASS_THROUGH           0x0
#define AEC_MODE_HALF_DUPLEX            0x1
#define AEC_MODE_FULL_DUPLEX            0x2

//===========================================================================
//===========================================================================

#define STATIC_CSPROPSETID_Wave\
    0x924e54b0L, 0x630f, 0x11cf, 0xad, 0xa7, 0x08, 0x00, 0x3e, 0x30, 0x49, 0x4a
DEFINE_GUIDSTRUCT("924e54b0-630f-11cf-ada7-08003e30494a", CSPROPSETID_Wave);
#define CSPROPSETID_Wave DEFINE_GUIDNAMED(CSPROPSETID_Wave)

typedef enum {
    CSPROPERTY_WAVE_COMPATIBLE_CAPABILITIES,
    CSPROPERTY_WAVE_INPUT_CAPABILITIES,
    CSPROPERTY_WAVE_OUTPUT_CAPABILITIES,
    CSPROPERTY_WAVE_BUFFER,
    CSPROPERTY_WAVE_FREQUENCY,
    CSPROPERTY_WAVE_VOLUME,
    CSPROPERTY_WAVE_PAN
} CSPROPERTY_WAVE;

typedef struct {
    ULONG        ulDeviceType;
} CSWAVE_COMPATCAPS, *PCSWAVE_COMPATCAPS;

#define CSWAVE_COMPATCAPS_INPUT                 0x00000000
#define CSWAVE_COMPATCAPS_OUTPUT                0x00000001

typedef struct {
    ULONG  MaximumChannelsPerConnection;
    ULONG  MinimumBitsPerSample;
    ULONG  MaximumBitsPerSample;
    ULONG  MinimumSampleFrequency;
    ULONG  MaximumSampleFrequency;
    ULONG  TotalConnections;
    ULONG  ActiveConnections;
} CSWAVE_INPUT_CAPABILITIES, *PCSWAVE_INPUT_CAPABILITIES;

typedef struct {
    ULONG  MaximumChannelsPerConnection;
    ULONG  MinimumBitsPerSample;
    ULONG  MaximumBitsPerSample;
    ULONG  MinimumSampleFrequency;
    ULONG  MaximumSampleFrequency;
    ULONG  TotalConnections;
    ULONG  StaticConnections;
    ULONG  StreamingConnections;
    ULONG  ActiveConnections;
    ULONG  ActiveStaticConnections;
    ULONG  ActiveStreamingConnections;
    ULONG  Total3DConnections;
    ULONG  Static3DConnections;
    ULONG  Streaming3DConnections;
    ULONG  Active3DConnections;
    ULONG  ActiveStatic3DConnections;
    ULONG  ActiveStreaming3DConnections;
    ULONG  TotalSampleMemory;
    ULONG  FreeSampleMemory;
    ULONG  LargestFreeContiguousSampleMemory;
} CSWAVE_OUTPUT_CAPABILITIES, *PCSWAVE_OUTPUT_CAPABILITIES;

typedef struct {
    LONG  LeftAttenuation;
    LONG  RightAttenuation;
} CSWAVE_VOLUME, *PCSWAVE_VOLUME;

#define CSWAVE_BUFFER_ATTRIBUTEF_LOOPING   0x00000001
#define CSWAVE_BUFFER_ATTRIBUTEF_STATIC    0x00000002

typedef struct {
    ULONG   Attributes;
    ULONG   BufferSize;
    PVOID   BufferAddress;
} CSWAVE_BUFFER, *PCSWAVE_BUFFER;

//===========================================================================
//===========================================================================

#define STATIC_CSMUSIC_TECHNOLOGY_PORT\
    0x86C92E60L, 0x62E8, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("86C92E60-62E8-11CF-A5D6-28DB04C10000", CSMUSIC_TECHNOLOGY_PORT);
#define CSMUSIC_TECHNOLOGY_PORT DEFINE_GUIDNAMED(CSMUSIC_TECHNOLOGY_PORT)

#define STATIC_CSMUSIC_TECHNOLOGY_SQSYNTH\
    0x0ECF4380L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("0ECF4380-62E9-11CF-A5D6-28DB04C10000", CSMUSIC_TECHNOLOGY_SQSYNTH);
#define CSMUSIC_TECHNOLOGY_SQSYNTH DEFINE_GUIDNAMED(CSMUSIC_TECHNOLOGY_SQSYNTH)

#define STATIC_CSMUSIC_TECHNOLOGY_FMSYNTH\
    0x252C5C80L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("252C5C80-62E9-11CF-A5D6-28DB04C10000", CSMUSIC_TECHNOLOGY_FMSYNTH);
#define CSMUSIC_TECHNOLOGY_FMSYNTH DEFINE_GUIDNAMED(CSMUSIC_TECHNOLOGY_FMSYNTH)

#define STATIC_CSMUSIC_TECHNOLOGY_WAVETABLE\
    0x394EC7C0L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("394EC7C0-62E9-11CF-A5D6-28DB04C10000", CSMUSIC_TECHNOLOGY_WAVETABLE);
#define CSMUSIC_TECHNOLOGY_WAVETABLE DEFINE_GUIDNAMED(CSMUSIC_TECHNOLOGY_WAVETABLE)

#define STATIC_CSMUSIC_TECHNOLOGY_SWSYNTH\
    0x37407736L, 0x3620, 0x11D1, 0x85, 0xD3, 0x00, 0x00, 0xF8, 0x75, 0x43, 0x80
DEFINE_GUIDSTRUCT("37407736-3620-11D1-85D3-0000F8754380", CSMUSIC_TECHNOLOGY_SWSYNTH);
#define CSMUSIC_TECHNOLOGY_SWSYNTH DEFINE_GUIDNAMED(CSMUSIC_TECHNOLOGY_SWSYNTH)

typedef struct {
   CSDATARANGE              DataRange;
   GUID                     Technology;
   ULONG                    Channels;
   ULONG                    Notes;
   ULONG                    ChannelMask;
} CSDATARANGE_MUSIC, *PCSDATARANGE_MUSIC;

//===========================================================================

#define STATIC_CSEVENTSETID_Cyclic\
    0x142C1AC0L, 0x072A, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("142C1AC0-072A-11D0-A5D6-28DB04C10000", CSEVENTSETID_Cyclic);
#define CSEVENTSETID_Cyclic DEFINE_GUIDNAMED(CSEVENTSETID_Cyclic)

typedef enum {
    CSEVENT_CYCLIC_TIME_INTERVAL,
} CSEVENT_CYCLIC_TIME;

//===========================================================================
#define STATIC_CSEVENTSETID_AudioControlChange\
    0xE85E9698L, 0xFA2F, 0x11D1, 0x95, 0xBD, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("E85E9698-FA2F-11D1-95BD-00C04FB925D3", CSEVENTSETID_AudioControlChange);
#define CSEVENTSETID_AudioControlChange DEFINE_GUIDNAMED(CSEVENTSETID_AudioControlChange)

typedef enum {
    CSEVENT_CONTROL_CHANGE,
} CSEVENT_AUDIO_CONTROL_CHANGE;

//===========================================================================
/*
#define STATIC_CSEVENTSETID_LoopedStreaming\
    0x4682B940L, 0xC6EF, 0x11D0, 0x96, 0xD8, 0x00, 0xAA, 0x00, 0x51, 0xE5, 0x1D
DEFINE_GUIDSTRUCT("4682B940-C6EF-11D0-96D8-00AA0051E51D", CSEVENTSETID_LoopedStreaming);
#define CSEVENTSETID_LoopedStreaming DEFINE_GUIDNAMED(CSEVENTSETID_LoopedStreaming)

typedef enum {
    CSEVENT_LOOPEDSTREAMING_POSITION,
} CSEVENT_LOOPEDSTREAMING;

typedef struct {
    CSEVENTDATA CsEventData;
#if defined(_NTDDK_)
    ULONGLONG   Position;
#else // !_NTDDK_
    DWORDLONG   Position;
#endif // !_NTDDK_
} LOOPEDSTREAMING_POSITION_EVENT_DATA, *PLOOPEDSTREAMING_POSITION_EVENT_DATA ;
*/

//===========================================================================
#define STATIC_CSPROPSETID_Sysaudio\
    0xCBE3FAA0L, 0xCC75, 0x11D0, 0xB4, 0x65, 0x00, 0x00, 0x1A, 0x18, 0x18, 0xE6
DEFINE_GUIDSTRUCT("CBE3FAA0-CC75-11D0-B465-00001A1818E6", CSPROPSETID_Sysaudio);
#define CSPROPSETID_Sysaudio DEFINE_GUIDNAMED(CSPROPSETID_Sysaudio)

typedef enum {
    CSPROPERTY_SYSAUDIO_DEVICE_COUNT = 1,
    CSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME = 2,
    CSPROPERTY_SYSAUDIO_DEVICE_INSTANCE = 3,
    CSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME = 4,
    CSPROPERTY_SYSAUDIO_SELECT_GRAPH = 5,
    CSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE = 6,
    CSPROPERTY_SYSAUDIO_DEVICE_DEFAULT = 7,
    CSPROPERTY_SYSAUDIO_INSTANCE_INFO = 14,
    CSPROPERTY_SYSAUDIO_COMPONENT_ID = 16,
} CSPROPERTY_SYSAUDIO;

typedef struct {
    CSPROPERTY Property;
    GUID PinCategory;
    GUID PinName;
} SYSAUDIO_CREATE_VIRTUAL_SOURCE, *PSYSAUDIO_CREATE_VIRTUAL_SOURCE;


typedef struct {
    CSPROPERTY Property;
    ULONG PinId;
    ULONG NodeId;
    ULONG Flags;
    ULONG Reserved;
} SYSAUDIO_SELECT_GRAPH, *PSYSAUDIO_SELECT_GRAPH;

typedef struct {
    CSPROPERTY Property;
    ULONG Flags;
    ULONG DeviceNumber;
} SYSAUDIO_INSTANCE_INFO, *PSYSAUDIO_INSTANCE_INFO;

#define SYSAUDIO_FLAGS_DONT_COMBINE_PINS        0x00000001


#define STATIC_CSPROPSETID_Sysaudio_Pin \
    0xA3A53220L, 0xC6E4, 0x11D0, 0xB4, 0x65, 0x00, 0x00, 0x1A, 0x18, 0x18, 0xE6
DEFINE_GUIDSTRUCT("A3A53220-C6E4-11D0-B465-00001A1818E6", CSPROPSETID_Sysaudio_Pin);
#define CSPROPSETID_Sysaudio_Pin DEFINE_GUIDNAMED(CSPROPSETID_Sysaudio_Pin)

typedef enum {
    CSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE = 1,
} CSPROPERTY_SYSAUDIO_PIN;

typedef struct {
    CSPROPERTY  Property;
    ULONG       MixerPinId;
    ULONG       Reserved;
} SYSAUDIO_ATTACH_VIRTUAL_SOURCE, *PSYSAUDIO_ATTACH_VIRTUAL_SOURCE;

//===========================================================================
typedef struct {
    CSPROPERTY  Property;
    ULONG       NodeId;
    ULONG       Reserved;
} CSNODEPROPERTY, *PCSNODEPROPERTY;

typedef struct {
    CSNODEPROPERTY NodeProperty;
    LONG           Channel;                   // value to get or set
    ULONG          Reserved;
} CSNODEPROPERTY_AUDIO_CHANNEL, *PCSNODEPROPERTY_AUDIO_CHANNEL;

typedef struct {
    CSNODEPROPERTY NodeProperty;
    ULONG   DevSpecificId;
    ULONG   DeviceInfo;
    ULONG   Length;
} CSNODEPROPERTY_AUDIO_DEV_SPECIFIC, *PCSNODEPROPERTY_AUDIO_DEV_SPECIFIC;

typedef struct {
    CSNODEPROPERTY   NodeProperty;
    PVOID            ListenerId;
#ifndef _WIN64
    ULONG            Reserved;
#endif // _WIN64
} CSNODEPROPERTY_AUDIO_3D_LISTENER, *PCSNODEPROPERTY_AUDIO_3D_LISTENER;

typedef struct {
    CSNODEPROPERTY   NodeProperty;
    PVOID            AppContext;
    ULONG            Length;
#ifndef _WIN64
    ULONG            Reserved;
#endif // _WIN64
} CSNODEPROPERTY_AUDIO_PROPERTY, *PCSNODEPROPERTY_AUDIO_PROPERTY;

//===========================================================================
// {79A9312E-59AE-43b0-A350-8B05284CAB24}
#define STATIC_CSPROPSETID_AudioGfx\
    0x79a9312eL, 0x59ae, 0x43b0, 0xa3, 0x50, 0x8b, 0x5, 0x28, 0x4c, 0xab, 0x24
DEFINE_GUIDSTRUCT("79A9312E-59AE-43b0-A350-8B05284CAB24", CSPROPSETID_AudioGfx);
#define CSPROPSETID_AudioGfx DEFINE_GUIDNAMED(CSPROPSETID_AudioGfx)

typedef enum {
    CSPROPERTY_AUDIOGFX_RENDERTARGETDEVICEID,
    CSPROPERTY_AUDIOGFX_CAPTURETARGETDEVICEID
} CSPROPERTY_AUDIOGFX;

//===========================================================================

//
// Midi definitions
//

/*
    Formats
*/

#define STATIC_CSDATAFORMAT_TYPE_MUSIC\
    0xE725D360L, 0x62CC, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("E725D360-62CC-11CF-A5D6-28DB04C10000", CSDATAFORMAT_TYPE_MUSIC);
#define CSDATAFORMAT_TYPE_MUSIC DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_MUSIC)

// 'mids' == MEDIATYPE_Midi
#define STATIC_CSDATAFORMAT_TYPE_MIDI\
    0x7364696DL, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("7364696D-0000-0010-8000-00aa00389b71", CSDATAFORMAT_TYPE_MIDI);
#define CSDATAFORMAT_TYPE_MIDI DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_MIDI)

#define STATIC_CSDATAFORMAT_SUBTYPE_MIDI\
    0x1D262760L, 0xE957, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1D262760-E957-11CF-A5D6-28DB04C10000", CSDATAFORMAT_SUBTYPE_MIDI);
#define CSDATAFORMAT_SUBTYPE_MIDI DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MIDI)

#define STATIC_CSDATAFORMAT_SUBTYPE_MIDI_BUS\
    0x2CA15FA0L, 0x6CFE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("2CA15FA0-6CFE-11CF-A5D6-28DB04C10000", CSDATAFORMAT_SUBTYPE_MIDI_BUS);
#define CSDATAFORMAT_SUBTYPE_MIDI_BUS DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MIDI_BUS)

#define STATIC_CSDATAFORMAT_SUBTYPE_RIFFMIDI\
    0x4995DAF0L, 0x9EE6, 0x11D0, 0xA4, 0x0E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("4995DAF0-9EE6-11D0-A40E-00A0C9223196", CSDATAFORMAT_SUBTYPE_RIFFMIDI);
#define CSDATAFORMAT_SUBTYPE_RIFFMIDI DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_RIFFMIDI)

/*
    CSDATAFORMAT_SUBTYPE_DIRECTMUSIC
    see DMusicCS.h
*/

// WARNING! This structure MUST be dword aligned
// regardless of the number of data bytes.

typedef struct {
    ULONG   TimeDeltaMs;        // Delta Milliseconds from the previous midiformat
                                // in the packet. The first midiformat in the packet
                                // is a delta from the PTS in the CSSTREAM_HEADER.
    ULONG   ByteCount;          // Number of bytes of data that follow this struct.
} CSMUSICFORMAT, *PCSMUSICFORMAT;

#endif //#ifndef UNDER_CE

//
// This entire set of MPEG Standard/Dialect Guids are obsolete. Do not use them.
//
//====================================================================================================
//====================================================================================================
// The following official MPEG Formats, Subtypes and Specifiers are listed as required or optional
// These official MPEG GUIDs are the preferred method of supporting MPEG/AC-3 media types in new code.
// Older MPEG GUIDs should also be supported for compatibilty, but these new modes are still required.
//====================================================================================================
//====================================================================================================

/*
This is a summary of what media types/specifiers will be required for all DVD+DSS+DVB+DTV MPEG decoders.
These media types are what the decoder driver must accept, hardware support for all of these media types
may or may not actually be provided by the decoder natively.  These media types are intended to define
the "officially" supported MPEG/AC-3 media types that all WHQL certified decoders must implement.  This
specifically includes driver and/or hardware support for all the required standards and dialects.

All MPEG video decoders must support all of the MPEG video modes shown as [required] below.
All MPEG audio decoders must support all of the MPEG audio modes shown as [required] below.
All AC-3 audio decoders must support all of the AC-3 audio modes shown as [required] below.
The line items shown as [optional] need not be implemented, but are possible formats that might be implemented.

Note that the input/output pin formats are defined by 2 or 3 GUIDs: TYPE, SUBTYPE, and maybe SPECIFIER.
The specifiers are included if the data format is a "dialect" that needs to be differentiated during decoding.
The decoder MUST be prepared to deal with ALL requests for _required_ "Standard" formats OR _required_ "Dialects".

STATIC_CSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM         [required]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO            [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO           [optional]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO            [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO           [optional]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [optional]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]
STATIC_CSDATAFORMAT_TYPE_STANDARD_PES_PACKET                [required]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO            [optional]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO           [optional]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO            [optional]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO           [optional]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [required]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]
STATIC_CSDATAFORMAT_TYPE_STANDARD_PACK_HEADER               [required]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [optional]
    STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]

Note that the SPECIFIER GUIDs normally identify particular versions of MPEG such as DSS and DVD.
This approach was taken to minimize the number of DSS/DVB/DVD/DTV etc. media SUBTYPES.
These specifiers are currently required to disambiguate MPEG syntax _parsing_ by the decoder
using alternate parsing routines or downloadable firmware or hardware decode settings.

In the future these specifiers will be extended to cover new CS MPEG flavors such as DVB and DTV.
Thus, the optional specifiers will be subject to clarification and/or definition as they are needed.

Important note: Per the ITU MPEG specs, MPEG 2 media may contain pure MPEG 1 syntax and
any "MPEG 2" PES packets may actually contain MPEG 1 payloads and MPEG 1 syntax.  Some MPEG
broadcasts can revert from MPEG2 to MPEG1 format data at their discretion, without warning.

CAUTION: Decoders MUST attempt to process MPEG data AS SOON AS POSSIBLE after reception.
In particular, elementary MPEG or MPEG PES packet streams should not be aggregated into DVD
"pack headers" internally before submission to the codec hardware if AT ALL POSSIBLE.  The
reason is that mpeg data may need to be processed immediately but there may be no additional
MPEG data forthcoming to fill up the PES packet OR DVD "pack" in a timely fashion.  This is
particularly true of MPEG dialects that utilize "repeat field signally" to reuse the last
decoded MPEG video field.

*/

/////////////////////////////////////////////////////////////////////////
// The major data type GUIDs that define the data packet encapsulation //
/////////////////////////////////////////////////////////////////////////

// STATIC_CSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM
#define STATIC_CSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM \
    0x36523b11L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B11-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM );
#define CSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM)

// STATIC_CSDATAFORMAT_TYPE_STANDARD_PES_PACKET
#define STATIC_CSDATAFORMAT_TYPE_STANDARD_PES_PACKET \
    0x36523b12L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B12-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_TYPE_STANDARD_PES_PACKET );
#define CSDATAFORMAT_TYPE_STANDARD_PES_PACKET DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_STANDARD_PES_PACKET)

// STATIC_CSDATAFORMAT_TYPE_STANDARD_PACK_HEADER
#define STATIC_CSDATAFORMAT_TYPE_STANDARD_PACK_HEADER \
    0x36523b13L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B13-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_TYPE_STANDARD_PACK_HEADER );
#define CSDATAFORMAT_TYPE_STANDARD_PACK_HEADER DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_STANDARD_PACK_HEADER)

///////////////////////////////////////////////////////////////////////////////
// The minor data subtype GUIDs that define the exact class of the data type.//
///////////////////////////////////////////////////////////////////////////////

// STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO
#define STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO \
    0x36523b21L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B21-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO );
#define CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO)

// STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO
#define STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO \
    0x36523b22L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B22-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO );
#define CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO)

// STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO
#define STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO \
    0x36523b23L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B23-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO );
#define CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO)

// STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO
#define STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO \
    0x36523b24L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B24-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO );
#define CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO)

// STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO
#define STATIC_CSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO \
    0x36523b25L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B25-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO );
#define CSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO)

///////////////////////////////////////////////////////////////////////////////
// The low-level specifier GUIDs that define the flavor of the data subtype. //
// Some SUBTYPES, notably MPEG2_VIDEO, MPEG2_AUDIO have different dialects.  //
// These specifiers are intended to be accompanied by a specifier structure. //
///////////////////////////////////////////////////////////////////////////////

// STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO
#define STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO \
    0x36523b31L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B31-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO );
#define CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO)

// STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO
#define STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO \
    0x36523b32L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B32-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO );
#define CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO)

// STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO    Associated with CS_MPEGVIDEOINFO2 defined later
#define STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO \
    0x36523b33L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B33-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO );
#define CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO)

// STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO    Associated with CS_MPEGAUDIOINFO defined later
#define STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO \
    0x36523b34L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B34-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO );
#define CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO)

// STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO
#define STATIC_CSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO \
    0x36523b35L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B35-8EE5-11d1-8CA3-0060B057664A", CSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO );
#define CSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO)

//====================================================================================================
//====================================================================================================
//                              *** COMPATIBILITY WARNING ***
// The *following* older DSS, MPEG, DVD & AC-3 GUID definitions are retained for backward compability.
// These MPEG GUIDs should also be supported for compatibilty, but the above newer modes are still required.
//====================================================================================================
//====================================================================================================

//
// DSS definitions
//

#define STATIC_CSDATAFORMAT_SUBTYPE_DSS_VIDEO\
    0xa0af4f81L, 0xe163, 0x11d0, 0xba, 0xd9, 0x00, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("a0af4f81-e163-11d0-bad9-00609744111a", CSDATAFORMAT_SUBTYPE_DSS_VIDEO);
#define CSDATAFORMAT_SUBTYPE_DSS_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_DSS_VIDEO)

#define STATIC_CSDATAFORMAT_SUBTYPE_DSS_AUDIO\
    0xa0af4f82L, 0xe163, 0x11d0, 0xba, 0xd9, 0x00, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("a0af4f82-e163-11d0-bad9-00609744111a", CSDATAFORMAT_SUBTYPE_DSS_AUDIO);
#define CSDATAFORMAT_SUBTYPE_DSS_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_DSS_AUDIO)

//
// End of obsolete MPEG definitions.
//

//
// mpeg 1 definitions
//
#define STATIC_CSDATAFORMAT_SUBTYPE_MPEG1Packet\
    0xe436eb80, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb80-524f-11ce-9F53-0020af0ba770", CSDATAFORMAT_SUBTYPE_MPEG1Packet);
#define CSDATAFORMAT_SUBTYPE_MPEG1Packet DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MPEG1Packet)

#define STATIC_CSDATAFORMAT_SUBTYPE_MPEG1Payload\
    0xe436eb81, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb81-524f-11ce-9F53-0020af0ba770", CSDATAFORMAT_SUBTYPE_MPEG1Payload);
#define CSDATAFORMAT_SUBTYPE_MPEG1Payload DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MPEG1Payload)

// MEDIASUBTYPE_MPEG1Video
#define STATIC_CSDATAFORMAT_SUBTYPE_MPEG1Video\
    0xe436eb86, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb86-524f-11ce-9f53-0020af0ba770", CSDATAFORMAT_SUBTYPE_MPEG1Video);
#define CSDATAFORMAT_SUBTYPE_MPEG1Video DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MPEG1Video)

//FORMAT_MPEGVideo
#define STATIC_CSDATAFORMAT_SPECIFIER_MPEG1_VIDEO\
    0x05589f82L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f82-c356-11ce-bf01-00aa0055595a", CSDATAFORMAT_SPECIFIER_MPEG1_VIDEO);
#define CSDATAFORMAT_SPECIFIER_MPEG1_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_MPEG1_VIDEO)

//
// mpeg 2 definitions
//
#define STATIC_CSDATAFORMAT_TYPE_MPEG2_PES\
    0xe06d8020L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8020-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_TYPE_MPEG2_PES);
#define CSDATAFORMAT_TYPE_MPEG2_PES DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_MPEG2_PES)

#define STATIC_CSDATAFORMAT_TYPE_MPEG2_PROGRAM\
    0xe06d8022L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8022-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_TYPE_MPEG2_PROGRAM);
#define CSDATAFORMAT_TYPE_MPEG2_PROGRAM DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_MPEG2_PROGRAM)

#define STATIC_CSDATAFORMAT_TYPE_MPEG2_TRANSPORT\
    0xe06d8023L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8023-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_TYPE_MPEG2_TRANSPORT);
#define CSDATAFORMAT_TYPE_MPEG2_TRANSPORT DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_MPEG2_TRANSPORT)

#define STATIC_CSDATAFORMAT_SUBTYPE_MPEG2_VIDEO\
    0xe06d8026L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8026-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SUBTYPE_MPEG2_VIDEO);
#define CSDATAFORMAT_SUBTYPE_MPEG2_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MPEG2_VIDEO)

// use MPEGVIDEOINFO2 (defined below) with CSDATAFORMAT_SPECIFIER_MPEG2_VIDEO
#define STATIC_CSDATAFORMAT_SPECIFIER_MPEG2_VIDEO\
    0xe06d80e3L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e3-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SPECIFIER_MPEG2_VIDEO);
#define CSDATAFORMAT_SPECIFIER_MPEG2_VIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_MPEG2_VIDEO)


//
// Mpeg2 video properties
//


#define STATIC_CSPROPSETID_Mpeg2Vid\
    0xC8E11B60L, 0x0CC9, 0x11D0, 0xBD, 0x69, 0x00, 0x35, 0x05, 0xC1, 0x03, 0xA9
DEFINE_GUIDSTRUCT("C8E11B60-0CC9-11D0-BD69-003505C103A9", CSPROPSETID_Mpeg2Vid);
#define  CSPROPSETID_Mpeg2Vid DEFINE_GUIDNAMED( CSPROPSETID_Mpeg2Vid )


typedef enum {
    CSPROPERTY_MPEG2VID_MODES,          // available output modes of decoder
    CSPROPERTY_MPEG2VID_CUR_MODE,       // current mode of the decoder
    CSPROPERTY_MPEG2VID_4_3_RECT,       // output coordinates for 4:3 source
    CSPROPERTY_MPEG2VID_16_9_RECT,      // output coordinates for 16:9 source
    CSPROPERTY_MPEG2VID_16_9_PANSCAN,   // pan and scan vectors
} CSPROPERTY_MPEG2VID;

//
// bit field definitions for MPEG2 VIDEO mode
//

#define CSMPEGVIDMODE_PANSCAN   0x0001
#define CSMPEGVIDMODE_LTRBOX    0x0002
#define CSMPEGVIDMODE_SCALE     0x0004

//
// rectangle definitions for the 4/3 and 16/9 cropping properties of
// the MPEG2Video decoder
//

typedef struct _CSMPEGVID_RECT {
    ULONG StartX;
    ULONG StartY;
    ULONG EndX;
    ULONG EndY;
} CSMPEGVID_RECT, *PCSMPEGVID_RECT;

//
// Params for pan / scan
//

#ifndef UNDER_CE
//
// MPEG2 Audio definition
//

#define STATIC_CSDATAFORMAT_SUBTYPE_MPEG2_AUDIO\
    0xe06d802bL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802b-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SUBTYPE_MPEG2_AUDIO);
#define CSDATAFORMAT_SUBTYPE_MPEG2_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_MPEG2_AUDIO)

#define STATIC_CSDATAFORMAT_SPECIFIER_MPEG2_AUDIO\
    0xe06d80e5L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e5-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SPECIFIER_MPEG2_AUDIO);
#define CSDATAFORMAT_SPECIFIER_MPEG2_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_MPEG2_AUDIO)

//
// DVD LPCM Audio definition
//

#define STATIC_CSDATAFORMAT_SUBTYPE_LPCM_AUDIO\
    0xe06d8032L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8032-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SUBTYPE_LPCM_AUDIO);
#define CSDATAFORMAT_SUBTYPE_LPCM_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_LPCM_AUDIO)

#define STATIC_CSDATAFORMAT_SPECIFIER_LPCM_AUDIO\
    0xe06d80e6L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e6-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SPECIFIER_LPCM_AUDIO);
#define CSDATAFORMAT_SPECIFIER_LPCM_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_LPCM_AUDIO)

//
// AC-3 definition
//

#define STATIC_CSDATAFORMAT_SUBTYPE_AC3_AUDIO\
    0xe06d802cL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802c-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SUBTYPE_AC3_AUDIO);
#define CSDATAFORMAT_SUBTYPE_AC3_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_AC3_AUDIO)

#define STATIC_CSDATAFORMAT_SPECIFIER_AC3_AUDIO\
    0xe06d80e4L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e4-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SPECIFIER_AC3_AUDIO);
#define CSDATAFORMAT_SPECIFIER_AC3_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_AC3_AUDIO)

#define STATIC_CSPROPSETID_AC3\
    0xBFABE720L, 0x6E1F, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("BFABE720-6E1F-11D0-BCF2-444553540000", CSPROPSETID_AC3);
#define CSPROPSETID_AC3 DEFINE_GUIDNAMED(CSPROPSETID_AC3)

typedef enum {
    CSPROPERTY_AC3_ERROR_CONCEALMENT = 1,
    CSPROPERTY_AC3_ALTERNATE_AUDIO,
    CSPROPERTY_AC3_DOWNMIX,
    CSPROPERTY_AC3_BIT_STREAM_MODE,
    CSPROPERTY_AC3_DIALOGUE_LEVEL,
    CSPROPERTY_AC3_LANGUAGE_CODE,
    CSPROPERTY_AC3_ROOM_TYPE
} CSPROPERTY_AC3;

typedef struct  {
    BOOL        fRepeatPreviousBlock;
    BOOL        fErrorInCurrentBlock;
} CSAC3_ERROR_CONCEALMENT, *PCSAC3_ERROR_CONCEALMENT;

typedef struct {
    BOOL    fStereo;
    ULONG   DualMode;
} CSAC3_ALTERNATE_AUDIO, *PCSAC3_ALTERNATE_AUDIO;

#define CSAC3_ALTERNATE_AUDIO_1     1
#define CSAC3_ALTERNATE_AUDIO_2     2
#define CSAC3_ALTERNATE_AUDIO_BOTH  3

typedef struct {
    BOOL        fDownMix;
    BOOL        fDolbySurround;
} CSAC3_DOWNMIX, *PCSAC3_DOWNMIX;

typedef struct {
    LONG        BitStreamMode;
} CSAC3_BIT_STREAM_MODE, *PCSAC3_BIT_STREAM_MODE;

#define CSAC3_SERVICE_MAIN_AUDIO            0
#define CSAC3_SERVICE_NO_DIALOG             1
#define CSAC3_SERVICE_VISUALLY_IMPAIRED     2
#define CSAC3_SERVICE_HEARING_IMPAIRED      3
#define CSAC3_SERVICE_DIALOG_ONLY           4
#define CSAC3_SERVICE_COMMENTARY            5
#define CSAC3_SERVICE_EMERGENCY_FLASH       6
#define CSAC3_SERVICE_VOICE_OVER            7

typedef struct {
    ULONG   DialogueLevel;
} CSAC3_DIALOGUE_LEVEL, *PCSAC3_DIALOGUE_LEVEL;

typedef struct {
    BOOL    fLargeRoom;
} CSAC3_ROOM_TYPE, *PCSAC3_ROOM_TYPE;


//
// DTS and SDDS definitions (media subtype GUIDs)
//
#define STATIC_CSDATAFORMAT_SUBTYPE_DTS_AUDIO\
    0xe06d8033L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8033-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SUBTYPE_DTS_AUDIO);
#define CSDATAFORMAT_SUBTYPE_DTS_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_DTS_AUDIO)

#define STATIC_CSDATAFORMAT_SUBTYPE_SDDS_AUDIO\
    0xe06d8034L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8034-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SUBTYPE_SDDS_AUDIO);
#define CSDATAFORMAT_SUBTYPE_SDDS_AUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_SDDS_AUDIO)


//
// audio decoder output properties
//

#define STATIC_CSPROPSETID_AudioDecoderOut\
    0x6ca6e020L, 0x43bd, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9
DEFINE_GUIDSTRUCT("6ca6e020-43bd-11d0-bd6a-003505c103a9", CSPROPSETID_AudioDecoderOut);
#define CSPROPSETID_AudioDecoderOut DEFINE_GUIDNAMED(CSPROPSETID_AudioDecoderOut)

typedef enum {
    CSPROPERTY_AUDDECOUT_MODES,         // available output modes of decoder
    CSPROPERTY_AUDDECOUT_CUR_MODE,      // current mode of the decoder
} CSPROPERTY_AUDDECOUT;

#define CSAUDDECOUTMODE_STEREO_ANALOG   0x0001
#define CSAUDDECOUTMODE_PCM_51          0x0002
#define CSAUDDECOUTMODE_SPDIFF          0x0004



//
// subpicture definition
//

#define STATIC_CSDATAFORMAT_SUBTYPE_SUBPICTURE\
    0xe06d802dL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802d-db46-11cf-b4d1-00805f6cbbea", CSDATAFORMAT_SUBTYPE_SUBPICTURE);
#define CSDATAFORMAT_SUBTYPE_SUBPICTURE DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_SUBPICTURE)


#define STATIC_CSPROPSETID_DvdSubPic\
    0xac390460L, 0x43af, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9
DEFINE_GUIDSTRUCT("ac390460-43af-11d0-bd6a-003505c103a9", CSPROPSETID_DvdSubPic);
#define CSPROPSETID_DvdSubPic DEFINE_GUIDNAMED(CSPROPSETID_DvdSubPic)

typedef enum {
    CSPROPERTY_DVDSUBPIC_PALETTE,
    CSPROPERTY_DVDSUBPIC_HLI,
    CSPROPERTY_DVDSUBPIC_COMPOSIT_ON,  // TRUE for subpicture is displayed
} CSPROPERTY_DVDSUBPIC;

typedef struct _CS_DVD_YCrCb {
    UCHAR   Reserved;
    UCHAR   Y;
    UCHAR   Cr;
    UCHAR   Cb;
} CS_DVD_YCrCb, *PCS_DVD_YCrCb;

/* The CS_DVD_YUV structure is now superseded by CS_DVD_YCrCb above and is
   here for backward compatibility only */

typedef struct _CS_DVD_YUV {
    UCHAR   Reserved;
    UCHAR   Y;
    UCHAR   V;
    UCHAR   U;
} CS_DVD_YUV, *PCS_DVD_YUV;

typedef struct _CSPROPERTY_SPPAL {
    CS_DVD_YUV sppal[16];
} CSPROPERTY_SPPAL, *PCSPROPERTY_SPPAL;

typedef struct _CS_COLCON {
    UCHAR emph1col:4;
    UCHAR emph2col:4;
    UCHAR backcol:4;
    UCHAR patcol:4;
    UCHAR emph1con:4;
    UCHAR emph2con:4;
    UCHAR backcon:4;
    UCHAR patcon:4;

} CS_COLCON, *PCS_COLCON;

typedef struct _CSPROPERTY_SPHLI {
    USHORT      HLISS;
    USHORT      Reserved;
    ULONG       StartPTM;   // start presentation time in x/90000
    ULONG       EndPTM;     // end PTM in x/90000
    USHORT      StartX;
    USHORT      StartY;
    USHORT      StopX;
    USHORT      StopY;
    CS_COLCON   ColCon;     // color contrast description (4 bytes as given in HLI)
} CSPROPERTY_SPHLI, *PCSPROPERTY_SPHLI;

typedef BOOL CSPROPERTY_COMPOSIT_ON, *PCSPROPERTY_COMPOSIT_ON;

#define STATIC_CSPROPSETID_CopyProt \
    0x0E8A0A40L, 0x6AEF, 0x11D0, 0x9E, 0xD0, 0x00, 0xA0, 0x24, 0xCA, 0x19, 0xB3
DEFINE_GUIDSTRUCT("0E8A0A40-6AEF-11D0-9ED0-00A024CA19B3", CSPROPSETID_CopyProt);
#define CSPROPSETID_CopyProt DEFINE_GUIDNAMED(CSPROPSETID_CopyProt)

typedef enum {

    CSPROPERTY_DVDCOPY_CHLG_KEY = 0x01,
    CSPROPERTY_DVDCOPY_DVD_KEY1,
    CSPROPERTY_DVDCOPY_DEC_KEY2,
    CSPROPERTY_DVDCOPY_TITLE_KEY,
    CSPROPERTY_COPY_MACROVISION,
    CSPROPERTY_DVDCOPY_REGION,
    CSPROPERTY_DVDCOPY_SET_COPY_STATE,
    CSPROPERTY_DVDCOPY_DISC_KEY = 0x80

} CSPROPERTY_COPYPROT;

typedef struct _CS_DVDCOPY_CHLGKEY {
    BYTE ChlgKey[10];
    BYTE Reserved[2];
} CS_DVDCOPY_CHLGKEY, *PCS_DVDCOPY_CHLGKEY;

typedef struct _CS_DVDCOPY_BUSKEY {
    BYTE BusKey[5];
    BYTE Reserved[1];
} CS_DVDCOPY_BUSKEY, *PCS_DVDCOPY_BUSKEY;


typedef struct _CS_DVDCOPY_DISCKEY {
    BYTE DiscKey[2048];
} CS_DVDCOPY_DISCKEY, *PCS_DVDCOPY_DISCKEY;

typedef struct _CS_DVDCOPY_REGION {
    UCHAR   Reserved;
    UCHAR   RegionData;
    UCHAR   Reserved2[2];
} CS_DVDCOPY_REGION, *PCS_DVDCOPY_REGION;

typedef struct _CS_DVDCOPY_TITLEKEY {
    ULONG KeyFlags;
    ULONG ReservedNT[2];
    UCHAR TitleKey[6];
    UCHAR Reserved[2];
} CS_DVDCOPY_TITLEKEY, *PCS_DVDCOPY_TITLEKEY;

typedef struct _CS_COPY_MACROVISION {
    ULONG MACROVISIONLevel;
} CS_COPY_MACROVISION, *PCS_COPY_MACROVISION;

typedef struct _CS_DVDCOPY_SET_COPY_STATE {
    ULONG DVDCopyState;
} CS_DVDCOPY_SET_COPY_STATE, *PCS_DVDCOPY_SET_COPY_STATE;

typedef enum {
    CS_DVDCOPYSTATE_INITIALIZE,         // indicates we are starting a full
                                        // copy protection sequence.
    CS_DVDCOPYSTATE_INITIALIZE_TITLE,   // indicates we are starting a title
                                        // key copy protection sequence
    CS_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED,
    CS_DVDCOPYSTATE_AUTHENTICATION_REQUIRED,
    CS_DVDCOPYSTATE_DONE,
} CS_DVDCOPYSTATE;

typedef enum {
    CS_MACROVISION_DISABLED,
    CS_MACROVISION_LEVEL1,
    CS_MACROVISION_LEVEL2,
    CS_MACROVISION_LEVEL3
} CS_COPY_MACROVISION_LEVEL, *PCS_COPY_MACROVISION_LEVEL;

//
// CGMS Copy Protection Flags
//

#define CS_DVD_CGMS_RESERVED_MASK      0x00000078

#define CS_DVD_CGMS_COPY_PROTECT_MASK  0x00000018
#define CS_DVD_CGMS_COPY_PERMITTED     0x00000000
#define CS_DVD_CGMS_COPY_ONCE          0x00000010
#define CS_DVD_CGMS_NO_COPY            0x00000018

#define CS_DVD_COPYRIGHT_MASK          0x00000040
#define CS_DVD_NOT_COPYRIGHTED         0x00000000
#define CS_DVD_COPYRIGHTED             0x00000040

#define CS_DVD_SECTOR_PROTECT_MASK     0x00000020
#define CS_DVD_SECTOR_NOT_PROTECTED    0x00000000
#define CS_DVD_SECTOR_PROTECTED        0x00000020


//===========================================================================
// The following MUST match the structures in WinGDI.h and AMVideo.h
//===========================================================================

#define STATIC_CSCATEGORY_TVTUNER \
    0xa799a800L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a800-a46d-11d0-a18c-00a02401dcd4", CSCATEGORY_TVTUNER);
#define CSCATEGORY_TVTUNER DEFINE_GUIDNAMED(CSCATEGORY_TVTUNER)

#define STATIC_CSCATEGORY_CROSSBAR \
    0xa799a801L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a801-a46d-11d0-a18c-00a02401dcd4", CSCATEGORY_CROSSBAR);
#define CSCATEGORY_CROSSBAR DEFINE_GUIDNAMED(CSCATEGORY_CROSSBAR)

#define STATIC_CSCATEGORY_TVAUDIO \
    0xa799a802L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a802-a46d-11d0-a18c-00a02401dcd4", CSCATEGORY_TVAUDIO);
#define CSCATEGORY_TVAUDIO DEFINE_GUIDNAMED(CSCATEGORY_TVAUDIO)

#define STATIC_CSCATEGORY_VPMUX \
    0xa799a803L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a803-a46d-11d0-a18c-00a02401dcd4", CSCATEGORY_VPMUX);
#define CSCATEGORY_VPMUX DEFINE_GUIDNAMED(CSCATEGORY_VPMUX)

#define STATIC_CSCATEGORY_VBICODEC \
    0x07dad660L, 0x22f1, 0x11d1, 0xa9, 0xf4, 0x00, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("07dad660-22f1-11d1-a9f4-00c04fbbde8f", CSCATEGORY_VBICODEC);
#define CSCATEGORY_VBICODEC DEFINE_GUIDNAMED(CSCATEGORY_VBICODEC)

#endif //#ifndef UNDER_CE

// SUBTYPE_VPVideo
#define STATIC_CSDATAFORMAT_SUBTYPE_VPVideo\
    0x5a9b6a40L, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("5a9b6a40-1a22-11d1-bad9-00609744111a", CSDATAFORMAT_SUBTYPE_VPVideo);
#define CSDATAFORMAT_SUBTYPE_VPVideo DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_VPVideo)

#ifndef UNDER_CE

// SUBTYPE_VPVBI
#define STATIC_CSDATAFORMAT_SUBTYPE_VPVBI\
    0x5a9b6a41L, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("5a9b6a41-1a22-11d1-bad9-00609744111a", CSDATAFORMAT_SUBTYPE_VPVBI);
#define CSDATAFORMAT_SUBTYPE_VPVBI DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_VPVBI)

#endif //#ifndef UNDER_CE

// FORMAT_VideoInfo
#define STATIC_CSDATAFORMAT_SPECIFIER_VIDEOINFO\
    0x05589f80L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f80-c356-11ce-bf01-00aa0055595a", CSDATAFORMAT_SPECIFIER_VIDEOINFO);
#define CSDATAFORMAT_SPECIFIER_VIDEOINFO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_VIDEOINFO)

// FORMAT_VideoInfo2
#define STATIC_CSDATAFORMAT_SPECIFIER_VIDEOINFO2\
    0xf72a76A0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76A0-eb0a-11d0-ace4-0000c0cc16ba", CSDATAFORMAT_SPECIFIER_VIDEOINFO2);
#define CSDATAFORMAT_SPECIFIER_VIDEOINFO2 DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_VIDEOINFO2)

// MEDIATYPE_AnalogVideo
#define STATIC_CSDATAFORMAT_TYPE_ANALOGVIDEO\
    0x0482dde1L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
DEFINE_GUIDSTRUCT("0482dde1-7817-11cf-8a03-00aa006ecb65", CSDATAFORMAT_TYPE_ANALOGVIDEO);
#define CSDATAFORMAT_TYPE_ANALOGVIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_ANALOGVIDEO)

// FORMAT_AnalogVideo
#define STATIC_CSDATAFORMAT_SPECIFIER_ANALOGVIDEO\
    0x0482dde0L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
DEFINE_GUIDSTRUCT("0482dde0-7817-11cf-8a03-00aa006ecb65", CSDATAFORMAT_SPECIFIER_ANALOGVIDEO);
#define CSDATAFORMAT_SPECIFIER_ANALOGVIDEO DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_ANALOGVIDEO)

// MEDIATYPE_AnalogAudio
#define STATIC_CSDATAFORMAT_TYPE_ANALOGAUDIO \
    0x0482dee1L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
DEFINE_GUIDSTRUCT("0482DEE1-7817-11cf-8a03-00aa006ecb65", CSDATAFORMAT_TYPE_ANALOGAUDIO);
#define CSDATAFORMAT_TYPE_ANALOGAUDIO DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_ANALOGAUDIO)

// FORMAT_VBI
#define STATIC_CSDATAFORMAT_SPECIFIER_VBI\
    0xf72a76e0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e0-eb0a-11d0-ace4-0000c0cc16ba", CSDATAFORMAT_SPECIFIER_VBI);
#define CSDATAFORMAT_SPECIFIER_VBI DEFINE_GUIDNAMED(CSDATAFORMAT_SPECIFIER_VBI)

// MEDIATYPE_VBI
#define STATIC_CSDATAFORMAT_TYPE_VBI\
    0xf72a76e1L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e1-eb0a-11d0-ace4-0000c0cc16ba", CSDATAFORMAT_TYPE_VBI);
#define CSDATAFORMAT_TYPE_VBI DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_VBI)

// SUBTYPE_RAW8
#define STATIC_CSDATAFORMAT_SUBTYPE_RAW8\
    0xca20d9a0, 0x3e3e, 0x11d1, 0x9b, 0xf9, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0xbf
DEFINE_GUIDSTRUCT("ca20d9a0-3e3e-11d1-9bf9-00c04fbbdebf", CSDATAFORMAT_SUBTYPE_RAW8);
#define CSDATAFORMAT_SUBTYPE_RAW8 DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_RAW8)

// MEDIASUBTYPE_CC
#define STATIC_CSDATAFORMAT_SUBTYPE_CC\
    0x33214cc1, 0x11f, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
DEFINE_GUIDSTRUCT("33214CC1-011F-11D2-B4B1-00A0D102CFBE", CSDATAFORMAT_SUBTYPE_CC);
#define CSDATAFORMAT_SUBTYPE_CC DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_CC)

// MEDIASUBTYPE_NABTS
#define STATIC_CSDATAFORMAT_SUBTYPE_NABTS\
    0xf72a76e2L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e2-eb0a-11d0-ace4-0000c0cc16ba", CSDATAFORMAT_SUBTYPE_NABTS);
#define CSDATAFORMAT_SUBTYPE_NABTS DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_NABTS)

// MEDIASUBTYPE_TELETEXT
#define STATIC_CSDATAFORMAT_SUBTYPE_TELETEXT\
    0xf72a76e3L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e3-eb0a-11d0-ace4-0000c0cc16ba", CSDATAFORMAT_SUBTYPE_TELETEXT);
#define CSDATAFORMAT_SUBTYPE_TELETEXT DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_TELETEXT)



/* constants for the biCompression field */
#define CS_BI_RGB        0L
#define CS_BI_RLE8       1L
#define CS_BI_RLE4       2L
#define CS_BI_BITFIELDS  3L

typedef struct tagCS_RGBQUAD { // rgbq
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} CS_RGBQUAD, *PCS_RGBQUAD;

/* constants for palettes */
#define CS_iPALETTE_COLORS 256     // Maximum colours in palette
#define CS_iEGA_COLORS 16          // Number colours in EGA palette
#define CS_iMASK_COLORS 3          // Maximum three components
#define CS_iTRUECOLOR 16           // Minimum true colour device
#define CS_iRED 0                  // Index position for RED mask
#define CS_iGREEN 1                // Index position for GREEN mask
#define CS_iBLUE 2                 // Index position for BLUE mask
#define CS_iPALETTE 8              // Maximum colour depth using a palette
#define CS_iMAXBITS 8              // Maximum bits per colour component
#define CS_SIZE_EGA_PALETTE (CS_iEGA_COLORS * sizeof(CS_RGBQUAD))
#define CS_SIZE_PALETTE (CS_iPALETTE_COLORS * sizeof(CS_RGBQUAD))

typedef struct tagCS_BITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} CS_BITMAPINFOHEADER, *PCS_BITMAPINFOHEADER;


// Used for true colour images that also have a palette

typedef struct tag_CS_TRUECOLORINFO {
    DWORD   dwBitMascs[CS_iMASK_COLORS];
    CS_RGBQUAD bmiColors[CS_iPALETTE_COLORS];
} CS_TRUECOLORINFO, *PCS_TRUECOLORINFO;


#define CS_WIDTHBYTES(bits) ((DWORD)(((bits)+31) & (~31)) / 8)
#define CS_DIBWIDTHBYTES(bi) (DWORD)CS_WIDTHBYTES((DWORD)(bi).biWidth * (DWORD)(bi).biBitCount)
#define CS__DIBSIZE(bi) (CS_DIBWIDTHBYTES(bi) * (DWORD)(bi).biHeight)
#define CS_DIBSIZE(bi) ((bi).biHeight < 0 ? (-1)*(CS__DIBSIZE(bi)) : CS__DIBSIZE(bi))

#define CS_DIBSTRIDEBYTES(bi) ((DWORD)(bi).biSizeImage/(DWORD)(bi).biHeight)

typedef LONGLONG REFERENCE_TIME;

// The BITMAPINFOHEADER contains all the details about the video stream such
// as the actual image dimensions and their pixel depth. A source filter may
// also request that the sink take only a section of the video by providing a
// clipping rectangle in rcSource. In the worst case where the sink filter
// forgets to check this on connection it will simply render the whole thing
// which isn't a disaster. Ideally a sink filter will check the rcSource and
// if it doesn't support image extraction and the rectangle is not empty then
// it will reject the connection. A filter should use SetRectEmpty to reset a
// rectangle to all zeroes (and IsRectEmpty to later check the rectangle).
// The rcTarget specifies the destination rectangle for the video, for most
// source filters they will set this to all zeroes, a downstream filter may
// request that the video be placed in a particular area of the buffers it
// supplies in which case it will call QueryAccept with a non empty target
typedef struct tagCS_VIDEOINFOHEADER {

    RECT                rcSource;          // The bit we really want to use
    RECT                rcTarget;          // Where the video should go
    DWORD               dwBitRate;         // Approximate bit data rate
    DWORD               dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME      AvgTimePerFrame;   // Average time per frame (100ns units)

    CS_BITMAPINFOHEADER bmiHeader;
    union 
    {
        DWORD               dwBitMasks[CS_iMASK_COLORS];       // True colour masks
        CS_TRUECOLORINFO    TrueColorInfo;                     // Both of the above
    };

} CS_VIDEOINFOHEADER, *PCS_VIDEOINFOHEADER;
// !!! WARNING !!!
// DO NOT use the following structure unless you are sure that the BITMAPINFOHEADER
// has a normal biSize == sizeof(BITMAPINFOHEADER) !
// !!! WARNING !!!

typedef struct tagCS_VIDEOINFO {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    CS_BITMAPINFOHEADER bmiHeader;

    union {
        DWORD               dwBitMasks[CS_iMASK_COLORS];       // True colour mascs
        CS_TRUECOLORINFO    TrueColorInfo;                     // Both of the above
    };

} CS_VIDEOINFO, *PCS_VIDEOINFO;


#define CS_SIZE_MASCS (CS_iMASK_COLORS * sizeof(DWORD))
#define CS_SIZE_PREHEADER (FIELD_OFFSET(CS_VIDEOINFOHEADER,bmiHeader))

// For normal size
// #define CS_SIZE_VIDEOHEADER (sizeof(CS_BITMAPINFOHEADER) + CS_SIZE_PREHEADER)
// !!! for abnormal biSizes
#define CS_SIZE_VIDEOHEADER(pbmi) ((pbmi)->bmiHeader.biSize + CS_SIZE_PREHEADER)

// VBI
// Used for NABTS, CC, Intercast, WST
typedef struct tagCS_VBIINFOHEADER {
    ULONG       StartLine;              // inclusive
    ULONG       EndLine;                // inclusive
    ULONG       SamplingFrequency;      // Hz.
    ULONG       MinLineStartTime;       // microSec * 100 from HSync LE
    ULONG       MaxLineStartTime;       // microSec * 100 from HSync LE
    ULONG       ActualLineStartTime;    // microSec * 100 from HSync LE
    ULONG       ActualLineEndTime;      // microSec * 100 from HSync LE
    ULONG       VideoStandard;          // CS_AnalogVideoStandard*
    ULONG       SamplesPerLine;
    ULONG       StrideInBytes;          // May be > SamplesPerLine
    ULONG       BufferSize;             // Bytes
} CS_VBIINFOHEADER, *PCS_VBIINFOHEADER;

// VBI Sampling Rates
#define CS_VBIDATARATE_NABTS            (5727272L)
#define CS_VBIDATARATE_CC               ( 503493L)    // ~= 1/1.986125e-6
#define CS_VBISAMPLINGRATE_4X_NABTS     ((long)(4*CS_VBIDATARATE_NABTS))
#define CS_VBISAMPLINGRATE_47X_NABTS    ((long)(27000000))
#define CS_VBISAMPLINGRATE_5X_NABTS     ((long)(5*CS_VBIDATARATE_NABTS))

#define CS_47NABTS_SCALER (CS_VBISAMPLINGRATE_47X_NABTS/(double)CS_VBIDATARATE_NABTS)

// Analog video variant - Use this when the format is FORMAT_AnalogVideo
//
// rcSource defines the portion of the active video signal to use
// rcTarget defines the destination rectangle
//    both of the above are relative to the dwActiveWidth and dwActiveHeight fields
// dwActiveWidth is currently set to 720 for all formats (but could change for HDTV)
// dwActiveHeight is 483 for NTSC and 575 for PAL/SECAM  (but could change for HDTV)

typedef struct tagCS_AnalogVideoInfo {
    RECT            rcSource;           // Width max is 720, height varies w/ TransmissionStd
    RECT            rcTarget;           // Where the video should go
    DWORD           dwActiveWidth;      // Always 720 (CCIR-601 active samples per line)
    DWORD           dwActiveHeight;     // 483 for NTSC, 575 for PAL/SECAM
    REFERENCE_TIME  AvgTimePerFrame;    // Normal ActiveMovie units (100 nS)
} CS_ANALOGVIDEOINFO, *PCS_ANALOGVIDEOINFO;

//===========================================================================
// Data packet passed on Analog video stream channel change
//===========================================================================

#define CS_TVTUNER_CHANGE_BEGIN_TUNE    0x0001L  // Starting a tuning operation
#define CS_TVTUNER_CHANGE_END_TUNE      0x0002L  // Ending a tuning operation

typedef struct tagCS_TVTUNER_CHANGE_INFO {
   DWORD                    dwFlags;                // CS_TVTUNER_CHANGE_*
   DWORD                    dwCountryCode;
   DWORD                    dwAnalogVideoStandard;  // CS_AnalogVideoStandard
   DWORD                    dwChannel;
} CS_TVTUNER_CHANGE_INFO, *PCS_TVTUNER_CHANGE_INFO;

//===========================================================================
// Video format bloccs
//===========================================================================

typedef enum {
    CS_MPEG2Level_Low,
    CS_MPEG2Level_Main,
    CS_MPEG2Level_High1440,
    CS_MPEG2Level_High
} CS_MPEG2Level;

typedef enum {
    CS_MPEG2Profile_Simple,
    CS_MPEG2Profile_Main,
    CS_MPEG2Profile_SNRScalable,
    CS_MPEG2Profile_SpatiallyScalable,
    CS_MPEG2Profile_High
} CS_MPEG2Profile;

#define CS_INTERLACE_IsInterlaced            0x00000001  // if 0, other interlace bits are irrelevent
#define CS_INTERLACE_1FieldPerSample         0x00000002  // else 2 fields per media sample
#define CS_INTERLACE_Field1First             0x00000004  // else Field 2 is first;  top field in PAL is field 1, top field in NTSC is field 2?
#define CS_INTERLACE_UNUSED                  0x00000008  //
#define CS_INTERLACE_FieldPatternMask        0x00000030  // use this mask with AMINTERLACE_FieldPat*
#define CS_INTERLACE_FieldPatField1Only      0x00000000  // Data never contains a Field2
#define CS_INTERLACE_FieldPatField2Only      0x00000010  // Data never contains a Field1
#define CS_INTERLACE_FieldPatBothRegular     0x00000020  // There will be a Field2 for every Field1 (required for Weave?)
#define CS_INTERLACE_FieldPatBothIrregular   0x00000030  // Random pattern of Field1s and Field2s
#define CS_INTERLACE_DisplayModeMask         0x000000c0
#define CS_INTERLACE_DisplayModeBobOnly      0x00000000
#define CS_INTERLACE_DisplayModeWeaveOnly    0x00000040
#define CS_INTERLACE_DisplayModeBobOrWeave   0x00000080



#define CS_MPEG2_DoPanScan           0x00000001  //if set, the MPEG-2 video decoder should crop output image
                                                //  based on pan-scan vectors in picture_display_extension
                                                //  and change the picture aspect ratio accordingly.
#define CS_MPEG2_DVDLine21Field1     0x00000002  //if set, the MPEG-2 decoder must be able to produce an output
                                                //  pin for DVD style closed caption data found in GOP layer of field 1
#define CS_MPEG2_DVDLine21Field2     0x00000004  //if set, the MPEG-2 decoder must be able to produce an output
                                                //  pin for DVD style closed caption data found in GOP layer of field 2
#define CS_MPEG2_SourceIsLetterboxed 0x00000008  //if set, indicates that black bars have been encoded in the top
                                                //  and bottom of the video.
#define CS_MPEG2_FilmCameraMode      0x00000010  //if set, indicates "film mode" used for 625/50 content.  If cleared,
                                                //  indicates that "camera mode" was used.
#define CS_MPEG2_LetterboxAnalogOut  0x00000020  //if set and this stream is sent to an analog output, it should
                        //  be letterboxed.  Streams sent to VGA should be letterboxed only by renderers.
#define CS_MPEG2_DSS_UserData        0x00000040  //if set, the MPEG-2 decoder must process DSS style user data
#define CS_MPEG2_DVB_UserData        0x00000080  //if set, the MPEG-2 decoder must process DVB style user data
#define CS_MPEG2_27MhzTimebase       0x00000100  //if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz

typedef struct tagCS_VIDEOINFOHEADER2 {
    RECT                rcSource;
    RECT                rcTarget;
    DWORD               dwBitRate;
    DWORD               dwBitErrorRate;
    REFERENCE_TIME      AvgTimePerFrame;
    DWORD               dwInterlaceFlags;   // use AMINTERLACE_* defines. Reject connection if undefined bits are not 0
    DWORD               dwCopyProtectFlags; // use AMCOPYPROTECT_* defines. Reject connection if undefined bits are not 0
    DWORD               dwPictAspectRatioX; // X dimension of picture aspect ratio, e.g. 16 for 16x9 display
    DWORD               dwPictAspectRatioY; // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
    DWORD               dwReserved1;        // must be 0; reject connection otherwise
    DWORD               dwReserved2;        // must be 0; reject connection otherwise
    CS_BITMAPINFOHEADER bmiHeader;
    union 
    {
        DWORD               dwBitMasks[CS_iMASK_COLORS];       // True colour masks
        CS_TRUECOLORINFO    TrueColorInfo;                     // Both of the above
    };

} CS_VIDEOINFOHEADER2, *PCS_VIDEOINFOHEADER2;

typedef struct tagCS_MPEG1VIDEOINFO {
    CS_VIDEOINFOHEADER hdr; // Compatible with VIDEOINFO
    DWORD dwStartTimeCode; // 25-bit Group of pictures time code at start of data
    DWORD cbSequenceHeader; // Length in bytes of bSequenceHeader
    BYTE bSequenceHeader[1]; // Sequence header including quantization matrices if any
} CS_MPEG1VIDEOINFO, *PCS_MPEG1VIDEOINFO;

#define CS_MAX_SIZE_MPEG1_SEQUENCE_INFO 140
#define CS_SIZE_MPEG1VIDEOINFO(pv) (FIELD_OFFSET(CS_MPEG1VIDEOINFO, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define CS_MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)

typedef struct tagCS_MPEGVIDEOINFO2 {
    CS_VIDEOINFOHEADER2 hdr;
    DWORD               dwStartTimeCode;        //  ?? not used for DVD ??
    DWORD               cbSequenceHeader;       // is 0 for DVD (no sequence header)
    DWORD               dwProfile;              // use enum MPEG2Profile
    DWORD               dwLevel;                // use enum MPEG2Level
    DWORD               dwFlags;                // use AMMPEG2_* defines.  Reject connection if undefined bits are not 0
    DWORD               bSequenceHeader[1];     // DWORD instead of Byte for alignment purposes
                                                //   For MPEG-2, if a sequence_header is included, the sequence_extension
                                                //   should also be included
} CS_MPEGVIDEOINFO2, *PCS_MPEGVIDEOINFO2;


#define CS_SIZE_MPEGVIDEOINFO2(pv) (FIELD_OFFSET(CS_MPEGVIDEOINFO2, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define CS_MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)

//===========================================================================
// Audio format bloccs
//===========================================================================

//if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz
#define CS_MPEGAUDIOINFO_27MhzTimebase      0x00000001

typedef struct tagCS_MPEAUDIOINFO {
    DWORD               dwFlags;            // use CS_MPEGAUDIOINFO_* defines.  Reject connection if undefined bits are not 0
    DWORD               dwReserved1;        // must be 0; reject connection otherwise
    DWORD               dwReserved2;        // must be 0; reject connection otherwise
    DWORD               dwReserved3;        // must be 0; reject connection otherwise
} CS_MPEGAUDIOINFO, *PCS_MPEGAUDIOINFO;

//===========================================================================
// Video DATAFORMATs
//===========================================================================

typedef struct tagCS_DATAFORMAT_VIDEOINFOHEADER {
    CSDATAFORMAT            DataFormat;
    CS_VIDEOINFOHEADER      VideoInfoHeader;
} CS_DATAFORMAT_VIDEOINFOHEADER, *PCS_DATAFORMAT_VIDEOINFOHEADER;

typedef struct tagCS_DATAFORMAT_VIDEOINFOHEADER2 {
    CSDATAFORMAT            DataFormat;
    CS_VIDEOINFOHEADER2     VideoInfoHeader2;
} CS_DATAFORMAT_VIDEOINFOHEADER2, *PCS_DATAFORMAT_VIDEOINFOHEADER2;

#ifdef UNDER_CE
typedef struct tagCS_DATAFORMAT_MPEG1_VIDEO {
    CSDATAFORMAT            DataFormat;
    CS_MPEG1VIDEOINFO       VideoInfoHeader;
} CS_DATAFORMAT_MPEG1_VIDEO, *OCS_DATAFORMAT_MPEG1_VIDEO;

typedef struct tagCS_DATAFORMAT_MPEG2_VIDEO {
    CSDATAFORMAT            DataFormat;
    CS_MPEG1VIDEOINFO       VideoInfoHeader;
} CS_DATAFORMAT_MPEG2_VIDEO, *PCS_DATAFORMAT_MPEG2_VIDEO;

#endif

typedef struct tagCS_DATAFORMAT_VIDEOINFO_PALETTE {
    CSDATAFORMAT            DataFormat;
    CS_VIDEOINFO            VideoInfo;
} CS_DATAFORMAT_VIDEOINFO_PALETTE, *PCS_DATAFORMAT_VIDEOINFO_PALETTE;

typedef struct tagCS_DATAFORMAT_VBIINFOHEADER {
    CSDATAFORMAT            DataFormat;
    CS_VBIINFOHEADER        VBIInfoHeader;
} CS_DATAFORMAT_VBIINFOHEADER, *PCS_DATAFORMAT_VBIINFOHEADER;

typedef struct  _CS_VIDEO_STREAM_CONFIG_CAPS  {
    GUID guid;                  // will be MEDIATYPE_Video
    ULONG VideoStandard;        // logical OR of all AnalogVideoStandards
                                // supported
    SIZE InputSize;             // the inherent size of the incoming signal
                                // (every pixel unique)
    SIZE MinCroppingSize;       // smallest rcSrc cropping rect allowed
    SIZE MaxCroppingSize;       // largest rcSrc cropping rect allowed
    int CropGranularityX;       // granularity of cropping size
    int CropGranularityY;
    int CropAlignX;             // alignment of cropping rect
    int CropAlignY;
    SIZE MinOutputSize;         // smallest bitmap stream can produce
    SIZE MaxOutputSize;         // largest  bitmap stream can produce
    int OutputGranularityX;     // granularity of output bitmap size
    int OutputGranularityY;
    int StretchTapsX;           // 0, no stretch, 1 pix dup, 2 interp, ...
    int StretchTapsY;           //    Describes quality of hardware scaler
    int ShrinkTapsX;            //
    int ShrinkTapsY;            //
    LONGLONG MinFrameInterval;  // 100 nS units
    LONGLONG MaxFrameInterval;
    LONG MinBitsPerSecond;
    LONG MaxBitsPerSecond;
} CS_VIDEO_STREAM_CONFIG_CAPS, *PCS_VIDEO_STREAM_CONFIG_CAPS;

//===========================================================================
// Video DATARANGEs
//===========================================================================

typedef struct tagCS_DATARANGE_VIDEO {
   CSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // CS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // CS_VIDEO_ALLOC_*
   CS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   CS_VIDEOINFOHEADER           VideoInfoHeader;        // default format
} CS_DATARANGE_VIDEO, *PCS_DATARANGE_VIDEO;

typedef struct tagCS_DATARANGE_VIDEO2 {
   CSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // CS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // CS_VIDEO_ALLOC_*
   CS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   CS_VIDEOINFOHEADER2          VideoInfoHeader;        // default format
} CS_DATARANGE_VIDEO2, *PCS_DATARANGE_VIDEO2;

typedef struct tagCS_DATARANGE_MPEG1_VIDEO {
    CSDATARANGE DataRange;
    BOOL bFixedSizeSamples; // all samples same size?
    BOOL bTemporalCompression; // all I frames?
    DWORD StreamDescriptionFlags; // CS_VIDEO_DESC_*
    DWORD MemoryAllocationFlags; // CS_VIDEO_ALLOC_*
    CS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
    CS_MPEG1VIDEOINFO VideoInfoHeader; // default format
} CS_DATARANGE_MPEG1_VIDEO, *PCS_DATARANGE_MPEG1_VIDEO;

typedef struct tagCS_DATARANGE_MPEG2_VIDEO {
   CSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // CS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // CS_VIDEO_ALLOC_*
   CS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   CS_MPEGVIDEOINFO2            VideoInfoHeader;        // default format
} CS_DATARANGE_MPEG2_VIDEO, *PCS_DATARANGE_MPEG2_VIDEO;

typedef struct tagCS_DATARANGE_VIDEO_PALETTE {
   CSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // CS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // CS_VIDEO_ALLOC_*
   CS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   CS_VIDEOINFO                 VideoInfo;              // default format
} CS_DATARANGE_VIDEO_PALETTE, *PCS_DATARANGE_VIDEO_PALETTE;

typedef struct tagCS_DATARANGE_VIDEO_VBI {
   CSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // CS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // CS_VIDEO_ALLOC_*
   CS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   CS_VBIINFOHEADER             VBIInfoHeader;          // default format
} CS_DATARANGE_VIDEO_VBI, *PCS_DATARANGE_VIDEO_VBI;

typedef struct tagCS_DATARANGE_ANALOGVIDEO {
   CSDATARANGE                  DataRange;
   CS_ANALOGVIDEOINFO           AnalogVideoInfo;
} CS_DATARANGE_ANALOGVIDEO, *PCS_DATARANGE_ANALOGVIDEO;

//===========================================================================
// StreamDescriptionFlags
//
// These define the "purpose" of each video stream
//===========================================================================

#define CS_VIDEOSTREAM_PREVIEW          0x0001  // Preview stream
#define CS_VIDEOSTREAM_CAPTURE          0x0002  // Capture stream
#define CS_VIDEOSTREAM_VBI              0x0010  // Field1 VBI
#define CS_VIDEOSTREAM_NABTS            0x0020  // Field1 NABTS
#define CS_VIDEOSTREAM_CC               0x0100  // Closed Captioning
#define CS_VIDEOSTREAM_EDS              0x0200  // Extended Data Services
#define CS_VIDEOSTREAM_TELETEXT         0x0400  // Field1 Teletext only
#define CS_VIDEOSTREAM_STILL            0x1000  // Still image input
#define CS_VIDEOSTREAM_IS_VPE           0x8000  // Is a VPE based stream?

// MemoryAllocationFlags
#define CS_VIDEO_ALLOC_VPE_SYSTEM       0x0001  // VPE surface in system memory
#define CS_VIDEO_ALLOC_VPE_DISPLAY      0x0002  // VPE surface in display memory
#define CS_VIDEO_ALLOC_VPE_AGP          0x0004  // VPE surface in AGP memory


#ifndef UNDER_CE
//////////////////////////////////////////////////////////////
// Capture driver VBI property sets
//////////////////////////////////////////////////////////////

// {F162C607-7B35-496f-AD7F-2DCA3B46B718}
#define STATIC_CSPROPSETID_VBICAP_PROPERTIES\
    0xf162c607, 0x7b35, 0x496f, 0xad, 0x7f, 0x2d, 0xca, 0x3b, 0x46, 0xb7, 0x18
DEFINE_GUIDSTRUCT("F162C607-7B35-496f-AD7F-2DCA3B46B718", CSPROPSETID_VBICAP_PROPERTIES);
#define CSPROPSETID_VBICAP_PROPERTIES DEFINE_GUIDNAMED(CSPROPSETID_VBICAP_PROPERTIES)

typedef enum {
    CSPROPERTY_VBICAP_PROPERTIES_PROTECTION = 0x01,
} CSPROPERTY_VBICAP;

typedef struct _VBICAP_PROPERTIES_PROTECTION_S {
    CSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      Status;
} VBICAP_PROPERTIES_PROTECTION_S, *PVBICAP_PROPERTIES_PROTECTION_S;
#define CS_VBICAP_PROTECTION_MV_PRESENT     0x0001L
#define CS_VBICAP_PROTECTION_MV_HARDWARE    0x0002L
#define CS_VBICAP_PROTECTION_MV_DETECTED    0x0004L


/***************************************************************************/
/* VBI Related GUIDs, structs and properties for codecs(generic, cc, nabts)*/
/***************************************************************************/

///////////////////////////////////////////////////////////////////////////////////////
// IP/NABTS Protocol Reserved Group IDs - Overall Range 0x800-0x8FF [Decimal 2048-2079]
// Intervening values(0-F) are used if there are multiple providers at a particular tier
///////////////////////////////////////////////////////////////////////////////////////

// Used by individual content creators in show footage/data
#define CS_NABTS_GROUPID_ORIGINAL_CONTENT_BASE                 0x800
#define CS_NABTS_GROUPID_ORIGINAL_CONTENT_ADVERTISER_BASE      0x810

// Used by production company in finished show data
#define CS_NABTS_GROUPID_PRODUCTION_COMPANY_CONTENT_BASE       0x820
#define CS_NABTS_GROUPID_PRODUCTION_COMPANY_ADVERTISER_BASE    0x830

// Used by broadcast syndicates in syndicated show data
#define CS_NABTS_GROUPID_SYNDICATED_SHOW_CONTENT_BASE          0x840
#define CS_NABTS_GROUPID_SYNDICATED_SHOW_ADVERTISER_BASE       0x850

// Used by tv networcs in network television data
#define CS_NABTS_GROUPID_NETWORK_WIDE_CONTENT_BASE             0x860
#define CS_NABTS_GROUPID_NETWORK_WIDE_ADVERTISER_BASE          0x870

// Used by telvision stations in local programming data
#define CS_NABTS_GROUPID_TELEVISION_STATION_CONTENT_BASE       0x880
#define CS_NABTS_GROUPID_TELEVISION_STATION_ADVERTISER_BASE    0x890

// Used by cable system in cable head-end originated data
#define CS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_CONTENT_BASE       0x8A0
#define CS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_ADVERTISER_BASE    0x8B0

// The values between 0x8C0 - 0x8EF are reserved for future expansion

// Used by Microsoft for Testing purposes (0x8F0 - 0x8FF)
#define CS_NABTS_GROUPID_MICROSOFT_RESERVED_TEST_DATA_BASE     0x8F0

//////////////////////////////////////////////////////////////
// Stream Format FEC-corrected NABTS bundles
//////////////////////////////////////////////////////////////

#define STATIC_CSDATAFORMAT_TYPE_NABTS \
 0xe757bca0, 0x39ac, 0x11d1, 0xa9, 0xf5, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("E757BCA0-39AC-11d1-A9F5-00C04FBBDE8F", CSDATAFORMAT_TYPE_NABTS);
#define CSDATAFORMAT_TYPE_NABTS DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_NABTS)

#define STATIC_CSDATAFORMAT_SUBTYPE_NABTS_FEC \
 0xe757bca1, 0x39ac, 0x11d1, 0xa9, 0xf5, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("E757BCA1-39AC-11d1-A9F5-00C04FBBDE8F", CSDATAFORMAT_SUBTYPE_NABTS_FEC);
#define CSDATAFORMAT_SUBTYPE_NABTS_FEC DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_NABTS_FEC)


//////////////////////////////////////////////////////////////
// NABTS Bundle data structure definition
//////////////////////////////////////////////////////////////

#define MAX_NABTS_VBI_LINES_PER_FIELD   11
#define NABTS_LINES_PER_BUNDLE          16
#define NABTS_PAYLOAD_PER_LINE          28
#define NABTS_BYTES_PER_LINE            36

typedef struct _NABTSFEC_BUFFER {
    ULONG       dataSize;
    USHORT      groupID;
    USHORT      Reserved;
    UCHAR       data[NABTS_LINES_PER_BUNDLE * NABTS_PAYLOAD_PER_LINE];
} NABTSFEC_BUFFER, *PNABTSFEC_BUFFER;

//////////////////////////////////////////////////////////////
// vbi codec filtering pin properties
//////////////////////////////////////////////////////////////

#define STATIC_CSPROPSETID_VBICodecFiltering \
    0xcafeb0caL, 0x8715, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0xc0, 0xed, 0xba, 0xbe
DEFINE_GUIDSTRUCT("cafeb0ca-8715-11d0-bd6a-0035c0edbabe", CSPROPSETID_VBICodecFiltering);
#define CSPROPSETID_VBICodecFiltering DEFINE_GUIDNAMED(CSPROPSETID_VBICodecFiltering)

typedef enum {
    CSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY = 0x01,
    CSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
    CSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
    CSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
    CSPROPERTY_VBICODECFILTERING_STATISTICS,
} CSPROPERTY_VBICODECFILTERING;

typedef struct _VBICODECFILTERING_SCANLINES {
    DWORD   DwordBitArray[32];      // An array of scanline bits 0..1024(32*32)
} VBICODECFILTERING_SCANLINES, *PVBICODECFILTERING_SCANLINES;

typedef struct _VBICODECFILTERING_NABTS_SUBSTREAMS {
    DWORD   SubstreamMask[128];   // An array of 4096 bits (one for each NABTS GroupID)
} VBICODECFILTERING_NABTS_SUBSTREAMS, *PVBICODECFILTERING_NABTS_SUBSTREAMS;

typedef struct _VBICODECFILTERING_CC_SUBSTREAMS {
    DWORD   SubstreamMask;        // An array of 32 bits (see CS_CC_SUBSTREAM *)
} VBICODECFILTERING_CC_SUBSTREAMS, *PVBICODECFILTERING_CC_SUBSTREAMS;

// These CS_CC_SUBSTREAM_* bitmascs are used with VBICODECFILTERING_CC_SUBSTREAMS
#define CS_CC_SUBSTREAM_ODD               0x0001L // Unfiltered Field 1 Data
#define CS_CC_SUBSTREAM_EVEN              0x0002L // Unfiltered Field 2 Data

// The following flags describe CC field 1 substreams: CC1,CC2,TT1,TT2
#define CS_CC_SUBSTREAM_FIELD1_MASK    	  0x00F0L
#define CS_CC_SUBSTREAM_SERVICE_CC1       0x0010L
#define CS_CC_SUBSTREAM_SERVICE_CC2       0x0020L
#define CS_CC_SUBSTREAM_SERVICE_T1        0x0040L
#define CS_CC_SUBSTREAM_SERVICE_T2        0x0080L

// The following flags describe CC field 2 substreams: CC3,CC4,TT3,TT4,XDS
#define CS_CC_SUBSTREAM_FIELD2_MASK       0x1F00L
#define CS_CC_SUBSTREAM_SERVICE_CC3       0x0100L
#define CS_CC_SUBSTREAM_SERVICE_CC4       0x0200L
#define CS_CC_SUBSTREAM_SERVICE_T3        0x0400L
#define CS_CC_SUBSTREAM_SERVICE_T4        0x0800L
#define CS_CC_SUBSTREAM_SERVICE_XDS       0x1000L

// Special Note: field 1 or 2 substreams are usually on found on field 1 and 2 respectively
// If the VBI odd/even polarity is reversed, the correct filtered data will still be found.

///////////////////////////////////////////////////////////////////
// Hardware decoded CC stream format
///////////////////////////////////////////////////////////////////

#define CC_MAX_HW_DECODE_LINES 12
typedef struct _CC_BYTE_PAIR {
    BYTE        Decoded[2];
    USHORT      Reserved;
} CC_BYTE_PAIR, *PCC_BYTE_PAIR;

typedef struct _CC_HW_FIELD {
    VBICODECFILTERING_SCANLINES  ScanlinesRequested;
    ULONG                        fieldFlags;    // CS_VBI_FLAG_FIELD1,2
    LONGLONG                     PictureNumber;
    CC_BYTE_PAIR                 Lines[CC_MAX_HW_DECODE_LINES];
} CC_HW_FIELD, *PCC_HW_FIELD;

///////////////////////////////////////////////////////////////////
// Raw NABTS stream format (TYPE_NABTS, SUBTYPE_NABTS)
///////////////////////////////////////////////////////////////////

// These low-level structures are byte packed( -Zp1 )
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <pshpack1.h>
#endif
typedef struct _NABTS_BUFFER_LINE {
    BYTE                            Confidence;
    BYTE                            Bytes[NABTS_BYTES_PER_LINE];
} NABTS_BUFFER_LINE, *PNABTS_BUFFER_LINE;

#define NABTS_BUFFER_PICTURENUMBER_SUPPORT 1
typedef struct _NABTS_BUFFER {
    VBICODECFILTERING_SCANLINES     ScanlinesRequested;
    LONGLONG                        PictureNumber;
    NABTS_BUFFER_LINE               NabtsLines[MAX_NABTS_VBI_LINES_PER_FIELD];
} NABTS_BUFFER, *PNABTS_BUFFER;
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <poppack.h>
#endif

//////////////////////////////////////////////////////////////
// WST Codec Teletext Media Sample Format
//////////////////////////////////////////////////////////////

#define WST_TVTUNER_CHANGE_BEGIN_TUNE    0x1000L  // Starting a tuning operation
#define WST_TVTUNER_CHANGE_END_TUNE      0x2000L  // Ending a tuning operation

#define MAX_WST_VBI_LINES_PER_FIELD   17
#define WST_BYTES_PER_LINE            42

typedef struct _WST_BUFFER_LINE {
    BYTE                            Confidence;
    BYTE                            Bytes[WST_BYTES_PER_LINE];
} WST_BUFFER_LINE, *PWST_BUFFER_LINE;

typedef struct _WST_BUFFER {
    VBICODECFILTERING_SCANLINES        ScanlinesRequested;
    WST_BUFFER_LINE                    WstLines[MAX_WST_VBI_LINES_PER_FIELD];
} WST_BUFFER, *PWST_BUFFER;

//
// Common codec statistics
//

typedef struct _VBICODECFILTERING_STATISTICS_COMMON {
    DWORD   InputSRBsProcessed;         // upstream SRBs received
    DWORD   OutputSRBsProcessed;        // downstream SRBs sent
    DWORD   SRBsIgnored;                // SRBs ignored due to no requests
    DWORD   InputSRBsMissing;           // SRBs dropped upstream
    DWORD   OutputSRBsMissing;          // Output dropped because no SRB pending
    DWORD   OutputFailures;             // dropped because of other failure
    DWORD   InternalErrors;             // could not process due to int. failure
    DWORD   ExternalErrors;             // could not process due to ext. failure
    DWORD   InputDiscontinuities;       // discontinuities received
    DWORD   DSPFailures;                // DSP confidence failure
    DWORD   TvTunerChanges;             // number of received CS_TVTUNER_CHANGE_BEGIN_TUNE and CS_TVTUNER_CHANGE_END_TUNE pairs.
    DWORD   VBIHeaderChanges;           // number of received CS_VBI_FLAG_VBIINFOHEADER_CHANGE
    DWORD   LineConfidenceAvg;          // Average of all DSP confidence results
    DWORD   BytesOutput;                // Bytes sent downstream
} VBICODECFILTERING_STATISTICS_COMMON, *PVBICODECFILTERING_STATISTICS_COMMON;

typedef struct _VBICODECFILTERING_STATISTICS_COMMON_PIN {
    DWORD   SRBsProcessed;              // SRBs sent/received
    DWORD   SRBsIgnored;                // SRBs ignored due to filtering
    DWORD   SRBsMissing;                // SRBs not sent/received
    DWORD   InternalErrors;             // could not send/receive due to int. failure
    DWORD   ExternalErrors;             // could not send/receive due to ext. failure
    DWORD   Discontinuities;            // discontinuities received/sent
    DWORD   LineConfidenceAvg;          // Average of all DSP confidence results for this pin
    DWORD   BytesOutput;                // Bytes sent downstream
} VBICODECFILTERING_STATISTICS_COMMON_PIN, *PVBICODECFILTERING_STATISTICS_COMMON_PIN;

//
// Codec-specific statistics - NABTS
//

typedef struct _VBICODECFILTERING_STATISTICS_NABTS {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
    DWORD   FECBundleBadLines;          // Un-FEC-correctable lines
    DWORD   FECQueueOverflows;          // Number of times FEC queue overflowed
    DWORD   FECCorrectedLines;          // Lines CSUM corrected by FEC
    DWORD   FECUncorrectableLines;      // FEC input lines not CSUM correctable
    DWORD   BundlesProcessed;           // Bundles received from FEC
    DWORD   BundlesSent2IP;             // Bundles sent to IP driver
    DWORD   FilteredLines;              // Lines processed and then dropped
                                        // because no one was interested
} VBICODECFILTERING_STATISTICS_NABTS, *PVBICODECFILTERING_STATISTICS_NABTS;

typedef struct _VBICODECFILTERING_STATISTICS_NABTS_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_NABTS_PIN, *PVBICODECFILTERING_STATISTICS_NABTS_PIN;

//
// Codec-specific statistics - Closed Caption
//

typedef struct _VBICODECFILTERING_STATISTICS_CC {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
} VBICODECFILTERING_STATISTICS_CC, *PVBICODECFILTERING_STATISTICS_CC;


typedef struct _VBICODECFILTERING_STATISTICS_CC_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_CC_PIN, *PVBICODECFILTERING_STATISTICS_CC_PIN;

//
// Codec-specific statistics - Closed Caption
//

typedef struct _VBICODECFILTERING_STATISTICS_TELETEXT {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
} VBICODECFILTERING_STATISTICS_TELETEXT, *PVBICODECFILTERING_STATISTICS_TELETEXT;

typedef struct _VBICODECFILTERING_STATISTICS_TELETEXT_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_TELETEXT_PIN, *PVBICODECFILTERING_STATISTICS_TELETEXT_PIN;

////////////////////////////////////////////////////////////////////////////
// VBI codec property structures(based on CSPROPERTY_VBICODECFILTERING enum)
////////////////////////////////////////////////////////////////////////////

// *** Most codecs support this property
//    CSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY
//    CSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
typedef struct {
    CSPROPERTY                          Property;
    VBICODECFILTERING_SCANLINES         Scanlines;
} CSPROPERTY_VBICODECFILTERING_SCANLINES_S, *PCSPROPERTY_VBICODECFILTERING_SCANLINES_S;

// *** NABTS codecs support this property
//    CSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
//    CSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
typedef struct {
    CSPROPERTY                          Property;
    VBICODECFILTERING_NABTS_SUBSTREAMS  Substreams;
} CSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S, *PCSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S;

// *** Closed captioning codecs support this property
//    CSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
//    CSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
typedef struct {
    CSPROPERTY                              Property;
    VBICODECFILTERING_CC_SUBSTREAMS         Substreams;
} CSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S, *PCSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S;

// *** Most codecs support these versions of the global and pin properties
//    CSPROPERTY_VBICODECFILTERING_STATISTICS
typedef struct {
    CSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_COMMON     Statistics;
} CSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S, *PCSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S;

typedef struct {
    CSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_COMMON_PIN Statistics;
} CSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S, *PCSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S;

// *** NABTS codecs support this version of the global and pin properties
//    CSPROPERTY_VBICODECFILTERING_STATISTICS
typedef struct {
    CSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_NABTS      Statistics;
} CSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S, *PCSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S;

typedef struct {
    CSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_NABTS_PIN  Statistics;
} CSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S, *PCSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S;

// *** Closed captioning codecs support this version of the global and pin properties
//    CSPROPERTY_VBICODECFILTERING_STATISTICS

typedef struct {
    CSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_CC         Statistics;
} CSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S, *PCSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S;

typedef struct {
    CSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_CC_PIN     Statistics;
} CSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S, *PCSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S;

#endif //#ifndef UNDER_CE

// Standard Pin Names for the video capture filter
//===========================================================================

#define STATIC_PINNAME_VIDEO_CAPTURE \
    0xfb6c4281, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define STATIC_PINNAME_CAPTURE STATIC_PINNAME_VIDEO_CAPTURE
DEFINE_GUIDSTRUCT("FB6C4281-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_CAPTURE);
#define PINNAME_VIDEO_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_CAPTURE)
#define PINNAME_CAPTURE PINNAME_VIDEO_CAPTURE

#ifndef UNDER_CE
#define STATIC_PINNAME_VIDEO_CC_CAPTURE \
    0x1aad8061, 0x12d, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
#define STATIC_PINNAME_CC_CAPTURE STATIC_PINNAME_VIDEO_CC_CAPTURE
DEFINE_GUIDSTRUCT("1AAD8061-012D-11d2-B4B1-00A0D102CFBE", PINNAME_VIDEO_CC_CAPTURE);
#define PINNAME_VIDEO_CC_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_CC_CAPTURE)

#define STATIC_PINNAME_VIDEO_NABTS_CAPTURE \
    0x29703660, 0x498a, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
#define STATIC_PINNAME_NABTS_CAPTURE STATIC_PINNAME_VIDEO_NABTS_CAPTURE
DEFINE_GUIDSTRUCT("29703660-498A-11d2-B4B1-00A0D102CFBE", PINNAME_VIDEO_NABTS_CAPTURE);
#define PINNAME_VIDEO_NABTS_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_NABTS_CAPTURE)
#endif //#ifndef UNDER_CE

#define STATIC_PINNAME_VIDEO_PREVIEW \
    0xfb6c4282, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define STATIC_PINNAME_PREVIEW STATIC_PINNAME_VIDEO_PREVIEW
DEFINE_GUIDSTRUCT("FB6C4282-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_PREVIEW);
#define PINNAME_VIDEO_PREVIEW DEFINE_GUIDNAMED(PINNAME_VIDEO_PREVIEW)
#define PINNAME_PREVIEW PINNAME_VIDEO_PREVIEW

#ifndef UNDER_CE
#define STATIC_PINNAME_VIDEO_ANALOGVIDEOIN \
    0xfb6c4283, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4283-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_ANALOGVIDEOIN);
#define PINNAME_VIDEO_ANALOGVIDEOIN DEFINE_GUIDNAMED(PINNAME_VIDEO_ANALOGVIDEOIN)

#define STATIC_PINNAME_VIDEO_VBI \
    0xfb6c4284, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4284-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VBI);
#define PINNAME_VIDEO_VBI DEFINE_GUIDNAMED(PINNAME_VIDEO_VBI)

#endif //#ifndef UNDER_CE

#define STATIC_PINNAME_VIDEO_VIDEOPORT \
    0xfb6c4285, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4285-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VIDEOPORT);
#define PINNAME_VIDEO_VIDEOPORT DEFINE_GUIDNAMED(PINNAME_VIDEO_VIDEOPORT)

#ifndef UNDER_CE

#define STATIC_PINNAME_VIDEO_NABTS \
    0xfb6c4286, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4286-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_NABTS);
#define PINNAME_VIDEO_NABTS DEFINE_GUIDNAMED(PINNAME_VIDEO_NABTS)

#define STATIC_PINNAME_VIDEO_EDS \
    0xfb6c4287, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4287-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_EDS);
#define PINNAME_VIDEO_EDS DEFINE_GUIDNAMED(PINNAME_VIDEO_EDS)

#define STATIC_PINNAME_VIDEO_TELETEXT \
    0xfb6c4288, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4288-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_TELETEXT);
#define PINNAME_VIDEO_TELETEXT DEFINE_GUIDNAMED(PINNAME_VIDEO_TELETEXT)

#define STATIC_PINNAME_VIDEO_CC \
    0xfb6c4289, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4289-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_CC);
#define PINNAME_VIDEO_CC DEFINE_GUIDNAMED(PINNAME_VIDEO_CC)
#endif //#ifndef UNDER_CE

#define STATIC_PINNAME_VIDEO_STILL \
    0xfb6c428A, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428A-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_STILL);
#define PINNAME_VIDEO_STILL DEFINE_GUIDNAMED(PINNAME_VIDEO_STILL)

#ifndef UNDER_CE
#define STATIC_PINNAME_VIDEO_TIMECODE \
    0xfb6c428B, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428B-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_TIMECODE);
#define PINNAME_VIDEO_TIMECODE DEFINE_GUIDNAMED(PINNAME_VIDEO_TIMECODE)

#define STATIC_PINNAME_VIDEO_VIDEOPORT_VBI \
    0xfb6c428C, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428C-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VIDEOPORT_VBI);
#define PINNAME_VIDEO_VIDEOPORT_VBI DEFINE_GUIDNAMED(PINNAME_VIDEO_VIDEOPORT_VBI)
#endif //#ifndef UNDER_CE

//===========================================================================
// CSSTREAM_HEADER extensions for digital video
//===========================================================================

#define CS_VIDEO_FLAG_FRAME      0x0000L        // Frame or Field (default is frame)
#define CS_VIDEO_FLAG_FIELD1     0x0001L
#define CS_VIDEO_FLAG_FIELD2     0x0002L

#define CS_VIDEO_FLAG_I_FRAME    0x0000L        // I, B, or P (default is I)
#define CS_VIDEO_FLAG_P_FRAME    0x0010L
#define CS_VIDEO_FLAG_B_FRAME    0x0020L

typedef struct tagCS_FRAME_INFO {
    ULONG                   ExtendedHeaderSize; // Size of this extended header
    DWORD                   dwFrameFlags;       // Field1, Field2, or Frame
    LONGLONG                PictureNumber;
    LONGLONG                DropCount;

    // The following are only set when using OverlayMixer
    HANDLE                  hDirectDraw;        // user mode DDraw handle
    HANDLE                  hSurfaceHandle;     // user mode surface handle
    RECT                    DirectDrawRect;     // portion of surface locked
    // Reserved fields, never reference these
    DWORD                   Reserved1;
    DWORD                   Reserved2;
    DWORD                   Reserved3;
    DWORD                   Reserved4;
} CS_FRAME_INFO, *PCS_FRAME_INFO;

#ifndef UNDER_CE
//===========================================================================
// CSSTREAM_HEADER extensions for VBI
//===========================================================================

#define CS_VBI_FLAG_FIELD1               0x0001L
#define CS_VBI_FLAG_FIELD2               0x0002L

#define CS_VBI_FLAG_MV_PRESENT           0x0100L
#define CS_VBI_FLAG_MV_HARDWARE          0x0200L
#define CS_VBI_FLAG_MV_DETECTED          0x0400L

#define CS_VBI_FLAG_TVTUNER_CHANGE       0x0010L // TvTunerChangeInfo is valid
#define CS_VBI_FLAG_VBIINFOHEADER_CHANGE 0x0020L // VBIInfoHeader is valid

typedef struct tagCS_VBI_FRAME_INFO {
    ULONG                   ExtendedHeaderSize; // Size of this extended header
    DWORD                   dwFrameFlags;  // Field1, Field2, or Frame; & etc
    LONGLONG                PictureNumber; // Test only?
    LONGLONG                DropCount;     // Test only?
    DWORD                   dwSamplingFrequency;
    CS_TVTUNER_CHANGE_INFO  TvTunerChangeInfo;
    CS_VBIINFOHEADER        VBIInfoHeader;
} CS_VBI_FRAME_INFO, *PCS_VBI_FRAME_INFO;


//===========================================================================
// Analog video formats, used with:
//      Analog Video Decoders
//      TVTuners
//      Analog Video Encoders
//
// XXX_STANDARDS_SUPPORTED returns a bitmask
//===========================================================================
#endif //#ifndef UNDER_CE
typedef enum
{
    CS_AnalogVideo_None     = 0x00000000  // This is a digital sensor
#ifndef UNDER_CE
	,
	CS_AnalogVideo_NTSC_M   = 0x00000001,  //        75 IRE Setup
    CS_AnalogVideo_NTSC_M_J = 0x00000002,  // Japan,  0 IRE Setup
    CS_AnalogVideo_NTSC_433 = 0x00000004,

    CS_AnalogVideo_PAL_B    = 0x00000010,
    CS_AnalogVideo_PAL_D    = 0x00000020,
    CS_AnalogVideo_PAL_G    = 0x00000040,
    CS_AnalogVideo_PAL_H    = 0x00000080,
    CS_AnalogVideo_PAL_I    = 0x00000100,
    CS_AnalogVideo_PAL_M    = 0x00000200,
    CS_AnalogVideo_PAL_N    = 0x00000400,

    CS_AnalogVideo_PAL_60   = 0x00000800,

    CS_AnalogVideo_SECAM_B  = 0x00001000,
    CS_AnalogVideo_SECAM_D  = 0x00002000,
    CS_AnalogVideo_SECAM_G  = 0x00004000,
    CS_AnalogVideo_SECAM_H  = 0x00008000,
    CS_AnalogVideo_SECAM_K  = 0x00010000,
    CS_AnalogVideo_SECAM_K1 = 0x00020000,
    CS_AnalogVideo_SECAM_L  = 0x00040000,
    CS_AnalogVideo_SECAM_L1 = 0x00080000,

    CS_AnalogVideo_PAL_N_COMBO
                            = 0x00100000
#endif //#ifndef UNDER_CE
} CS_AnalogVideoStandard;

#ifndef UNDER_CE
#define CS_AnalogVideo_NTSC_Mask  0x00000007
#define CS_AnalogVideo_PAL_Mask   0x00100FF0
#define CS_AnalogVideo_SECAM_Mask 0x000FF000

//===========================================================================
// Property set definitions
// The comments show whether a given property is:
//      R  : READ only
//      w  : WRITE only
//      RW : READ / WRITE
//      O  : Optional (return E_UNSUPPORTED if you don't handle this)
//===========================================================================

#define STATIC_PROPSETID_ALLOCATOR_CONTROL\
    0x53171960, 0x148e, 0x11d2, 0x99, 0x79, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("53171960-148E-11d2-9979-0000C0CC16BA", PROPSETID_ALLOCATOR_CONTROL);
#define PROPSETID_ALLOCATOR_CONTROL DEFINE_GUIDNAMED(PROPSETID_ALLOCATOR_CONTROL)
typedef enum {
    CSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT,      // R O (will allocate exactly this number of buffers)
    CSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE,     // R O (return 2 DWORDs specifying surface size)
    // W I (informn a capture driver whether interleave capture is possible or
    //      not - a value of 1 means that interleaved capture is supported)
    CSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS,
 
    // R O (if value == 1, then the ovmixer will turn on the DDVP_INTERLEAVE
    //      flag thus allowing interleaved capture of the video)
    CSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE,
} CSPROPERTY_ALLOCATOR_CONTROL;

typedef struct {
    //CSPROPERTY Property;
    ULONG	CX;
	ULONG	CY;
} CSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S, *PCSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S; 
 
typedef struct {
    //CSPROPERTY Property;
    ULONG	InterleavedCapSupported;
} CSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S, *PCSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S;

 
typedef struct {
    //CSPROPERTY Property;
    ULONG	InterleavedCapPossible;
} CSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S, *PCSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S;

#endif //#ifndef UNDER_CE

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_VIDEOPROCAMP\
    0xC6E13360L, 0x30AC, 0x11d0, 0xa1, 0x8c, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13360-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEOPROCAMP);
#define PROPSETID_VIDCAP_VIDEOPROCAMP DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOPROCAMP)

typedef enum {
    CSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,            // RW O
    CSPROPERTY_VIDEOPROCAMP_CONTRAST,              // RW O
    CSPROPERTY_VIDEOPROCAMP_HUE,                   // RW O
    CSPROPERTY_VIDEOPROCAMP_SATURATION,            // RW O
    CSPROPERTY_VIDEOPROCAMP_SHARPNESS,             // RW O
    CSPROPERTY_VIDEOPROCAMP_GAMMA,                 // RW O
    CSPROPERTY_VIDEOPROCAMP_COLORENABLE,           // RW O
    CSPROPERTY_VIDEOPROCAMP_WHITEBALANCE,          // RW O
    CSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION,// RW O
    CSPROPERTY_VIDEOPROCAMP_GAIN,                  // RW O
} CSPROPERTY_VIDCAP_VIDEOPROCAMP;

typedef struct {
    CSPROPERTY Property;
    LONG   Value;                       // Value to set or get
    ULONG  Flags;                       // CSPROPERTY_VIDEOPROCAMP_FLAGS_*
    ULONG  Capabilities;                // CSPROPERTY_VIDEOPROCAMP_FLAGS_*
} CSPROPERTY_VIDEOPROCAMP_S, *PCSPROPERTY_VIDEOPROCAMP_S;

#define CSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO        0X0001L
#define CSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL      0X0002L

//===========================================================================
#ifndef UNDER_CE
#define STATIC_PROPSETID_TUNER\
    0x6a2e0605L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0605-28e4-11d0-a18c-00a0c9118956", PROPSETID_TUNER);
#define PROPSETID_TUNER DEFINE_GUIDNAMED(PROPSETID_TUNER)

typedef enum {
    CSPROPERTY_TUNER_CAPS,              // R  -overall device capabilities
    CSPROPERTY_TUNER_MODE_CAPS,         // R  -capabilities in this mode
    CSPROPERTY_TUNER_MODE,              // RW -set a mode (TV, FM, AM, DSS)
    CSPROPERTY_TUNER_STANDARD,          // R  -get TV standard (only if TV mode)
    CSPROPERTY_TUNER_FREQUENCY,         // RW -set/get frequency
    CSPROPERTY_TUNER_INPUT,             // RW -select an input
    CSPROPERTY_TUNER_STATUS,            // R  -tuning status
    CSPROPERTY_TUNER_IF_MEDIUM          // R O-Medium for IF or Transport Pin
} CSPROPERTY_TUNER;

typedef enum {
    CSPROPERTY_TUNER_MODE_TV            = 0X0001,
    CSPROPERTY_TUNER_MODE_FM_RADIO      = 0X0002,
    CSPROPERTY_TUNER_MODE_AM_RADIO      = 0X0004,
    CSPROPERTY_TUNER_MODE_DSS           = 0X0008,
    CSPROPERTY_TUNER_MODE_ATSC          = 0X0010,  // also used for DVB-T, DVB-C
} CSPROPERTY_TUNER_MODES;

// Describes how the device tunes.  Only one of these flags may be set
// in CSPROPERTY_TUNER_MODE_CAPS_S.Strategy

// Describe how the driver should attempt to tune:
// EXACT:   just go to the frequency specified (no fine tuning)
// FINE:    (slow) do an exhaustive search for the best signal
// COARSE:  (fast) use larger frequency jumps to just determine if any signal

typedef enum {
    CS_TUNER_TUNING_EXACT = 1,        // No fine tuning
    CS_TUNER_TUNING_FINE,             // Fine grained search
    CS_TUNER_TUNING_COARSE,           // Coarse search
}CS_TUNER_TUNING_FLAGS;

typedef enum {
    CS_TUNER_STRATEGY_PLL             = 0X01, // Tune by PLL offset
    CS_TUNER_STRATEGY_SIGNAL_STRENGTH = 0X02, // Tune by signal strength
    CS_TUNER_STRATEGY_DRIVER_TUNES    = 0X04, // Driver does fine tuning
}CS_TUNER_STRATEGY;

typedef struct {
    CSPROPERTY Property;
    ULONG  ModesSupported;              // CS_PROPERTY_TUNER_MODES_*
    CSPIN_MEDIUM VideoMedium;           // GUID_NULL (no pin), or GUID
    CSPIN_MEDIUM TVAudioMedium;         // GUID_NULL (no pin), or GUID
    CSPIN_MEDIUM RadioAudioMedium;      // GUID_NULL (no pin), or GUID
} CSPROPERTY_TUNER_CAPS_S, *PCSPROPERTY_TUNER_CAPS_S;

typedef struct {
    CSPROPERTY Property;
    CSPIN_MEDIUM IFMedium;              // GUID_NULL (no pin), or GUID
} CSPROPERTY_TUNER_IF_MEDIUM_S, *PCSPROPERTY_TUNER_IF_MEDIUM_S;

typedef struct {
    CSPROPERTY Property;
    ULONG  Mode;                        // IN: CSPROPERTY_TUNER_MODE
    ULONG  StandardsSupported;          // CS_AnalogVideo_* (if TV or DSS)
    ULONG  MinFrequency;                // Hz
    ULONG  MaxFrequency;                // Hz
    ULONG  TuningGranularity;           // Hz
    ULONG  NumberOfInputs;              // count of inputs
    ULONG  SettlingTime;                // milliSeconds
    ULONG  Strategy;                    // CS_TUNER_STRATEGY
} CSPROPERTY_TUNER_MODE_CAPS_S, *PCSPROPERTY_TUNER_MODE_CAPS_S;

typedef struct {
    CSPROPERTY Property;
    ULONG  Mode;                        // IN: CSPROPERTY_TUNER_MODE
} CSPROPERTY_TUNER_MODE_S, *PCSPROPERTY_TUNER_MODE_S;

typedef struct {
    CSPROPERTY Property;
    ULONG  Frequency;                   // Hz
    ULONG  LastFrequency;               // Hz (last known good)
    ULONG  TuningFlags;                 // CS_TUNER_TUNING_FLAGS
    ULONG  VideoSubChannel;             // DSS
    ULONG  AudioSubChannel;             // DSS
    ULONG  Channel;                     // VBI decoders
    ULONG  Country;                     // VBI decoders
} CSPROPERTY_TUNER_FREQUENCY_S, *PCSPROPERTY_TUNER_FREQUENCY_S;

typedef struct {
    CSPROPERTY Property;
    ULONG  Standard;                    // CS_AnalogVideo_*
} CSPROPERTY_TUNER_STANDARD_S, *PCSPROPERTY_TUNER_STANDARD_S;

typedef struct {
    CSPROPERTY Property;
    ULONG  InputIndex;                  // 0 to (n-1) inputs
} CSPROPERTY_TUNER_INPUT_S, *PCSPROPERTY_TUNER_INPUT_S;

typedef struct {
    CSPROPERTY Property;
    ULONG  CurrentFrequency;            // Hz
    ULONG  PLLOffset;                   // if Strategy.CS_TUNER_STRATEGY_PLL
    ULONG  SignalStrength;              // if Stretegy.CS_TUNER_STRATEGY_SIGNAL_STRENGTH
    ULONG  Busy;                        // TRUE if in the process of tuning
} CSPROPERTY_TUNER_STATUS_S, *PCSPROPERTY_TUNER_STATUS_S;

#define STATIC_EVENTSETID_TUNER\
    0x6a2e0606L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0606-28e4-11d0-a18c-00a0c9118956", EVENTSETID_TUNER);
#define EVENTSETID_TUNER DEFINE_GUIDNAMED(EVENTSETID_TUNER)

typedef enum {
    CSEVENT_TUNER_CHANGED
} CSEVENT_TUNER;


//===========================================================================

#define STATIC_PROPSETID_VIDCAP_VIDEOENCODER\
    0x6a2e0610L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0610-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_VIDEOENCODER);
#define PROPSETID_VIDCAP_VIDEOENCODER DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOENCODER)

typedef enum {
    CSPROPERTY_VIDEOENCODER_CAPS,                       // R
    CSPROPERTY_VIDEOENCODER_STANDARD,                   // RW
    CSPROPERTY_VIDEOENCODER_COPYPROTECTION,             // RW O
    CSPROPERTY_VIDEOENCODER_CC_ENABLE,                  // RW O
} CSPROPERTY_VIDCAP_VIDEOENCODER;

typedef struct {
    CSPROPERTY Property;
    LONG       Value;                   // value to get or set
    ULONG      Flags;                   //
    ULONG      Capabilities;            //
} CSPROPERTY_VIDEOENCODER_S, *PCSPROPERTY_VIDEOENCODER_S;

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_VIDEODECODER\
    0xC6E13350L, 0x30AC, 0x11d0, 0xA1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13350-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEODECODER);
#define PROPSETID_VIDCAP_VIDEODECODER DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEODECODER)

typedef enum {
    CSPROPERTY_VIDEODECODER_CAPS,                       // R
    CSPROPERTY_VIDEODECODER_STANDARD,                   // RW
    CSPROPERTY_VIDEODECODER_STATUS,                     // R
    CSPROPERTY_VIDEODECODER_OUTPUT_ENABLE,              // Rw O
    CSPROPERTY_VIDEODECODER_VCR_TIMING,                 // RW O
} CSPROPERTY_VIDCAP_VIDEODECODER;

typedef enum {
    CS_VIDEODECODER_FLAGS_CAN_DISABLE_OUTPUT  = 0X0001, // VP Output can tri-stae
    CS_VIDEODECODER_FLAGS_CAN_USE_VCR_LOCKING = 0X0002, // VCR PLL timings
    CS_VIDEODECODER_FLAGS_CAN_INDICATE_LOCKED = 0X0004, // Can indicate valid signal
}CS_VIDEODECODER_FLAGS;

typedef struct {
    CSPROPERTY Property;
    ULONG      StandardsSupported;      // CS_AnalogVideo_*
    ULONG      Capabilities;            // CS_VIDEODECODER_FLAGS_*
    ULONG      SettlingTime;            // milliseconds
    ULONG      HSyncPerVSync;           // Number of HSync Pulses per VSync
} CSPROPERTY_VIDEODECODER_CAPS_S, *PCSPROPERTY_VIDEODECODER_CAPS_S;

typedef struct {
    CSPROPERTY Property;
    ULONG      NumberOfLines;           // 525 or 625 lines detected
    ULONG      SignalLocked;            // TRUE if signal is locked
} CSPROPERTY_VIDEODECODER_STATUS_S, *PCSPROPERTY_VIDEODECODER_STATUS_S;

typedef struct {
    CSPROPERTY Property;
    ULONG      Value;                   // Get or set a value
} CSPROPERTY_VIDEODECODER_S, *PCSPROPERTY_VIDEODECODER_S;

#define STATIC_EVENTSETID_VIDEODECODER\
    0x6a2e0621L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0621-28e4-11d0-a18c-00a0c9118956", EVENTSETID_VIDEODECODER);
#define EVENTSETID_VIDEODECODER DEFINE_GUIDNAMED(EVENTSETID_VIDEODECODER)

typedef enum {
    CSEVENT_VIDEODECODER_CHANGED
} CSEVENT_VIDEODECODER;
#endif //#ifndef UNDER_CE

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_CAMERACONTROL\
    0xC6E13370L, 0x30AC, 0x11d0, 0xa1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13370-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_CAMERACONTROL);
#define PROPSETID_VIDCAP_CAMERACONTROL DEFINE_GUIDNAMED(PROPSETID_VIDCAP_CAMERACONTROL)

typedef enum {
    CSPROPERTY_CAMERACONTROL_PAN,                       // RW O
    CSPROPERTY_CAMERACONTROL_TILT,                      // RW O
    CSPROPERTY_CAMERACONTROL_ROLL,                      // RW O
    CSPROPERTY_CAMERACONTROL_ZOOM,                      // RW O
    CSPROPERTY_CAMERACONTROL_EXPOSURE,                  // RW O
    CSPROPERTY_CAMERACONTROL_IRIS,                      // RW O
    CSPROPERTY_CAMERACONTROL_FOCUS,                     // RW O
    CSPROPERTY_CAMERACONTROL_FLASH,                     // RW O
} CSPROPERTY_VIDCAP_CAMERACONTROL;

typedef struct {
    CSPROPERTY Property;
    LONG       Value;                   // value to get or set
    ULONG      Flags;                   // CSPROPERTY_CAMERACONTROL_FLAGS_*
    ULONG      Capabilities;            // CSPROPERTY_CAMERACONTROL_FLAGS_*
} CSPROPERTY_CAMERACONTROL_S, *PCSPROPERTY_CAMERACONTROL_S;

#define CSPROPERTY_CAMERACONTROL_FLAGS_AUTO        0X0001L
#define CSPROPERTY_CAMERACONTROL_FLAGS_MANUAL      0X0002L

#define CSPROPERTY_CAMERACONTROL_FLAGS_ABSOLUTE    0X0000L
#define CSPROPERTY_CAMERACONTROL_FLAGS_RELATIVE    0X0010L

#ifndef UNDER_CE
#ifndef __EDevCtrl__
#define __EDevCtrl__
//===========================================================================

#define STATIC_PROPSETID_EXT_DEVICE\
    0xB5730A90L, 0x1A2C, 0x11cf, 0x8c, 0x23, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("B5730A90-1A2C-11cf-8C23-00AA006B6814", PROPSETID_EXT_DEVICE);
#define PROPSETID_EXT_DEVICE DEFINE_GUIDNAMED(PROPSETID_EXT_DEVICE)

typedef enum {
    CSPROPERTY_EXTDEVICE_ID,                // R
    CSPROPERTY_EXTDEVICE_VERSION,           // R
    CSPROPERTY_EXTDEVICE_POWER_STATE,       // RW
    CSPROPERTY_EXTDEVICE_PORT,              // R
    CSPROPERTY_EXTDEVICE_CAPABILITIES,      // R
} CSPROPERTY_EXTDEVICE;

typedef struct tagDEVCAPS{
    LONG CanRecord;
    LONG CanRecordStrobe;
    LONG HasAudio;
    LONG HasVideo;
    LONG UsesFiles;
    LONG CanSave;
    LONG DeviceType;
    LONG TCRead;
    LONG TCWrite;
    LONG CTLRead;
    LONG IndexRead;
    LONG Preroll;
    LONG Postroll;
    LONG SyncAcc;
    LONG NormRate;
    LONG CanPreview;
    LONG CanMonitorSrc;
    LONG CanTest;
    LONG VideoIn;
    LONG AudioIn;
    LONG Calibrate;
    LONG SeekType;
    LONG SimulatedHardware;        
} DEVCAPS, *PDEVCAPS;

typedef struct {
    CSPROPERTY Property;
    union {
        DEVCAPS  Capabilities;          // Device capabilities
        ULONG    DevPort;               // 1394, USB, etc.
        ULONG    PowerState;            // On, standby or off
        WCHAR    pawchString[MAX_PATH]; // Version
        DWORD    NodeUniqueID[2];       // Unique NodeID
    } u;
} CSPROPERTY_EXTDEVICE_S, *PCSPROPERTY_EXTDEVICE_S;

//===========================================================================

#define STATIC_PROPSETID_EXT_TRANSPORT\
    0xA03CD5F0L, 0x3045, 0x11cf, 0x8c, 0x44, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("A03CD5F0-3045-11cf-8C44-00AA006B6814", PROPSETID_EXT_TRANSPORT);
#define PROPSETID_EXT_TRANSPORT DEFINE_GUIDNAMED(PROPSETID_EXT_TRANSPORT)

typedef enum {
    CSPROPERTY_EXTXPORT_CAPABILITIES,       // (R)  Transport specific capability 
    CSPROPERTY_EXTXPORT_INPUT_SIGNAL_MODE,  // (RW) Input signal: e.g. dvsd/NTSC/PAL, dvsl/NTSC/PAL, MPEG2-TS etc
    CSPROPERTY_EXTXPORT_OUTPUT_SIGNAL_MODE, // (RW) Output signal: e.g. dvsd/NTSC/PAL, dvsl/NTSC/PAL, MPEG2-TS etc
    CSPROPERTY_EXTXPORT_LOAD_MEDIUM,        // (RW) Eject, open tray, close tray
    CSPROPERTY_EXTXPORT_MEDIUM_INFO,        // (R)  Cassettte type, tape grade and write protection
    CSPROPERTY_EXTXPORT_STATE,              // (RW) Current transport mode and state
    CSPROPERTY_EXTXPORT_STATE_NOTIFY,       // (RW) Notify of transport mode and state change
    CSPROPERTY_EXTXPORT_TIMECODE_SEARCH,    // (W)  Search to a specific timecode on a tape
    CSPROPERTY_EXTXPORT_ATN_SEARCH,         // (W)  Search to a specific absolute track number (ATN) on a tape
    CSPROPERTY_EXTXPORT_RTC_SEARCH,         // (W)  Search to a specific relative time counter (RTC) on a tape
    CSPROPERTY_RAW_AVC_CMD,                 // (RW) Issue a raw AVC commnad
} CSPROPERTY_EXTXPORT;

typedef struct tagTRANSPORTSTATUS{
    LONG Mode;
    LONG LastError;
    LONG RecordInhibit;
    LONG ServoLock;
    LONG MediaPresent;
    LONG MediaLength;
    LONG MediaSize;
    LONG MediaTrackCount;
    LONG MediaTrackLength;
    LONG MediaTrackSide;
    LONG MediaType;
    LONG LinkMode;
    LONG NotifyOn;
} TRANSPORTSTATUS, *PTRANSPORTSTATUS;

typedef struct tagTRANSPORTBASICPARMS{
    LONG TimeFormat;
    LONG TimeReference;
    LONG Superimpose;
    LONG EndStopAction;
    LONG RecordFormat;
    LONG StepFrames;
    LONG SetpField;
    LONG Preroll;
    LONG RecPreroll;
    LONG Postroll;
    LONG EditDelay;
    LONG PlayTCDelay;
    LONG RecTCDelay;
    LONG EditField;
    LONG FrameServo;
    LONG ColorFrameServo;
    LONG ServoRef;
    LONG WarnGenlock;
    LONG SetTracking;
    TCHAR VolumeName[40];
    LONG Ballistic[20];
    LONG Speed;
    LONG CounterFormat;
    LONG TunerChannel;
    LONG TunerNumber;
    LONG TimerEvent;
    LONG TimerStartDay;
    LONG TimerStartTime;
    LONG TimerStopDay;
    LONG TimerStopTime;
} TRANSPORTBASICPARMS, *PTRANSPORTBASICPARMS;

typedef struct tagTRANSPORTVIDEOPARMS{
    LONG OutputMode;
    LONG Input;
} TRANSPORTVIDEOPARMS, *PTRANSPORTVIDEOPARMS;

typedef struct tagTRANSPORTAUDIOPARMS{
    LONG EnableOutput;
    LONG EnableRecord;
    LONG EnableSelsync;
    LONG Input;
    LONG MonitorSource;
} TRANSPORTAUDIOPARMS, *PTRANSPORTAUDIOPARMS;

typedef struct {
    BOOL  MediaPresent;      
    ULONG MediaType;         
    BOOL  RecordInhibit;    
} MEDIUM_INFO, *PMEDIUM_INFO;

typedef struct {
    ULONG Mode;              
    ULONG State;
} TRANSPORT_STATE, *PTRANSPORT_STATE;

typedef struct {
    CSPROPERTY Property;
    union {    
        ULONG      Capabilities;
        ULONG      SignalMode;
        ULONG      LoadMedium;
        MEDIUM_INFO MediumInfo;
        TRANSPORT_STATE XPrtState;
        struct {
          BYTE frame;        
          BYTE second;
          BYTE minute;
          BYTE hour;
        } Timecode;
        DWORD dwTimecode;            
        DWORD dwAbsTrackNumber;      
        struct {
            ULONG   PayloadSize;
            BYTE    Payload[512];  
        } RawAVC;                    
    } u;
     
} CSPROPERTY_EXTXPORT_S, *PCSPROPERTY_EXTXPORT_S;

//===========================================================================

#define STATIC_PROPSETID_TIMECODE_READER\
    0x9B496CE1L, 0x811B, 0x11cf, 0x8C, 0x77, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("9B496CE1-811B-11cf-8C77-00AA006B6814", PROPSETID_TIMECODE_READER);
#define PROPSETID_TIMECODE_READER DEFINE_GUIDNAMED(PROPSETID_TIMECODE_READER)

typedef enum {
    CSPROPERTY_TIMECODE_READER,  // (R) Timecode for the current tape position
    CSPROPERTY_ATN_READER,       // (R) Absolute track number for the current tape position
    CSPROPERTY_RTC_READER,       // (R) Relative time counter for the current tape position
} CSPROPERTY_TIMECODE;

#ifndef TIMECODE_DEFINED
#define TIMECODE_DEFINED
typedef union _timecode {
    struct {
        WORD   wFrameRate;
        WORD   wFrameFract;
        DWORD  dwFrames;
        };
    DWORDLONG  qw;
} TIMECODE;
typedef TIMECODE *PTIMECODE;

typedef struct tagTIMECODE_SAMPLE {
    LONGLONG qwTick;
    TIMECODE timecode;
    DWORD dwUser;
    DWORD dwFlags;
} TIMECODE_SAMPLE;

typedef TIMECODE_SAMPLE *PTIMECODE_SAMPLE;

#endif /* TIMECODE_DEFINED */

typedef struct {
    CSPROPERTY Property;
    TIMECODE_SAMPLE TimecodeSamp;
} CSPROPERTY_TIMECODE_S, *PCSPROPERTY_TIMECODE_S;

//===========================================================================

#define STATIC_CSEVENTSETID_EXTDEV_Command\
    0x109c7988L, 0xb3cb, 0x11d2, 0xb4, 0x8e, 0x00, 0x60, 0x97, 0xb3, 0x39, 0x1b
DEFINE_GUIDSTRUCT("109c7988-b3cb-11d2-b48e-006097b3391b", CSEVENTSETID_EXTDEV_Command);
#define CSEVENTSETID_EXTDEV_Command DEFINE_GUIDNAMED(CSEVENTSETID_EXTDEV_Command)

typedef enum {
    CSEVENT_EXTDEV_COMMAND_NOTIFY_INTERIM_READY,     // Final response is ready for notify command 
    CSEVENT_EXTDEV_COMMAND_CONTROL_INTERIM_READY,    // Final response is ready for control command.
    CSEVENT_EXTDEV_COMMAND_BUSRESET,                 // A bus reset has occured.
    CSEVENT_EXTDEV_TIMECODE_UPDATE,                  // Timecode has changed.
    CSEVENT_EXTDEV_OPERATION_MODE_UPDATE,            // Operting mode (VCR,Camera, etc.) has changed.
    CSEVENT_EXTDEV_TRANSPORT_STATE_UPDATE,           // Transport state has changed.
    CSEVENT_EXTDEV_NOTIFY_REMOVAL,                   // Device was surprise removal.
    CSEVENT_EXTDEV_NOTIFY_MEDIUM_CHANGE,             // Tape medium is removed or added.
} CSEVENT_DEVCMD;

#endif // __EDevCtrl__

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_CROSSBAR\
    0x6a2e0640L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0640-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_CROSSBAR);
#define PROPSETID_VIDCAP_CROSSBAR DEFINE_GUIDNAMED(PROPSETID_VIDCAP_CROSSBAR)

typedef enum {
    CSPROPERTY_CROSSBAR_CAPS,                     // R
    CSPROPERTY_CROSSBAR_PININFO,                  // R
    CSPROPERTY_CROSSBAR_CAN_ROUTE,                // R
    CSPROPERTY_CROSSBAR_ROUTE,                    // RW
} CSPROPERTY_VIDCAP_CROSSBAR;

typedef struct {
    CSPROPERTY Property;
    ULONG  NumberOfInputs;      // the number of audio and video input pins
    ULONG  NumberOfOutputs;     // the number of audio and video output pins
} CSPROPERTY_CROSSBAR_CAPS_S, *PCSPROPERTY_CROSSBAR_CAPS_S;

typedef struct {
    CSPROPERTY Property;
    CSPIN_DATAFLOW Direction;     // CSPIN_DATAFLOW_IN or CSPIN_DATAFLOW_OUT?
    ULONG  Index;                 // Which pin to return data for?
    ULONG  PinType;               // CS_PhysConn_Video_* or CS_PhysConn_Audio_*
    ULONG  RelatedPinIndex;       // For video pins, this is the related audio pin
    CSPIN_MEDIUM  Medium;         // Identifies the hardware connection
} CSPROPERTY_CROSSBAR_PININFO_S, *PCSPROPERTY_CROSSBAR_PININFO_S;

typedef struct {
    CSPROPERTY Property;
    ULONG  IndexInputPin;        // Zero based index of the input pin
    ULONG  IndexOutputPin;       // Zero based index of the output pin
    ULONG  CanRoute;             // returns non-zero on CAN_ROUTE if routing is possible
} CSPROPERTY_CROSSBAR_ROUTE_S, *PCSPROPERTY_CROSSBAR_ROUTE_S;

#define STATIC_EVENTSETID_CROSSBAR\
    0x6a2e0641L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0641-28e4-11d0-a18c-00a0c9118956", EVENTSETID_CROSSBAR);
#define EVENTSETID_CROSSBAR DEFINE_GUIDNAMED(EVENTSETID_CROSSBAR)

typedef enum {
    CSEVENT_CROSSBAR_CHANGED
} CSEVENT_CROSSBAR;

// The following IDs should match the AM equivalents
typedef enum {
    CS_PhysConn_Video_Tuner = 1,
    CS_PhysConn_Video_Composite,
    CS_PhysConn_Video_SVideo,
    CS_PhysConn_Video_RGB,
    CS_PhysConn_Video_YRYBY,
    CS_PhysConn_Video_SerialDigital,
    CS_PhysConn_Video_ParallelDigital,
    CS_PhysConn_Video_SCSI,
    CS_PhysConn_Video_AUX,
    CS_PhysConn_Video_1394,
    CS_PhysConn_Video_USB,
    CS_PhysConn_Video_VideoDecoder,
    CS_PhysConn_Video_VideoEncoder,
    CS_PhysConn_Video_SCART,

    CS_PhysConn_Audio_Tuner = 4096,
    CS_PhysConn_Audio_Line,
    CS_PhysConn_Audio_Mic,
    CS_PhysConn_Audio_AESDigital,
    CS_PhysConn_Audio_SPDIFDigital,
    CS_PhysConn_Audio_SCSI,
    CS_PhysConn_Audio_AUX,
    CS_PhysConn_Audio_1394,
    CS_PhysConn_Audio_USB,
    CS_PhysConn_Audio_AudioDecoder,
} CS_PhysicalConnectorType;


//===========================================================================

#define STATIC_PROPSETID_VIDCAP_TVAUDIO\
    0x6a2e0650L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0650-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_TVAUDIO);
#define PROPSETID_VIDCAP_TVAUDIO DEFINE_GUIDNAMED(PROPSETID_VIDCAP_TVAUDIO)

typedef enum {
    CSPROPERTY_TVAUDIO_CAPS,                            // R
    CSPROPERTY_TVAUDIO_MODE,                            // RW
    CSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES        // R
} CSPROPERTY_VIDCAP_TVAUDIO;

#define CS_TVAUDIO_MODE_MONO           0x0001          // Mono
#define CS_TVAUDIO_MODE_STEREO         0x0002          // Stereo
#define CS_TVAUDIO_MODE_LANG_A         0x0010          // Primary language
#define CS_TVAUDIO_MODE_LANG_B         0x0020          // 2nd avail language
#define CS_TVAUDIO_MODE_LANG_C         0x0040          // 3rd avail language

typedef struct {
    CSPROPERTY Property;
    ULONG      Capabilities;             // Bitmask of CS_TVAUDIO_MODE_*
    CSPIN_MEDIUM InputMedium;
    CSPIN_MEDIUM OutputMedium;
} CSPROPERTY_TVAUDIO_CAPS_S, *PCSPROPERTY_TVAUDIO_CAPS_S;

typedef struct {
    CSPROPERTY Property;
    ULONG      Mode;                     // CS_TVAUDIO_MODE_*
} CSPROPERTY_TVAUDIO_S, *PCSPROPERTY_TVAUDIO_S;


#define STATIC_CSEVENTSETID_VIDCAP_TVAUDIO\
    0x6a2e0651L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0651-28e4-11d0-a18c-00a0c9118956", CSEVENTSETID_VIDCAP_TVAUDIO);
#define CSEVENTSETID_VIDCAP_TVAUDIO DEFINE_GUIDNAMED(CSEVENTSETID_VIDCAP_TVAUDIO)

typedef enum {
    CSEVENT_TVAUDIO_CHANGED,
} CSEVENT_TVAUDIO;

#endif //#ifndef UNDER_CE

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_VIDEOCOMPRESSION\
    0xC6E13343L, 0x30AC, 0x11d0, 0xA1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13343-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEOCOMPRESSION);
#define PROPSETID_VIDCAP_VIDEOCOMPRESSION DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOCOMPRESSION)

typedef enum {
    CSPROPERTY_VIDEOCOMPRESSION_GETINFO,              // R
    CSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE,        // RW
    CSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME, // RW
    CSPROPERTY_VIDEOCOMPRESSION_QUALITY,              // RW
    CSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_KEYFRAME,    // W
    CSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_FRAME_SIZE,  // W
    CSPROPERTY_VIDEOCOMPRESSION_WINDOWSIZE,           // RW
} CSPROPERTY_VIDCAP_VIDEOCOMPRESSION;

typedef enum {
    CS_CompressionCaps_CanQuality = 1,
    CS_CompressionCaps_CanCrunch = 2,
    CS_CompressionCaps_CanKeyFrame = 4,
    CS_CompressionCaps_CanBFrame = 8,
    CS_CompressionCaps_CanWindow = 0x10,
} CS_CompressionCaps;

typedef struct {
    CSPROPERTY Property;
    // Note, no VersionString!
    // Note, no DescriptionString!
    ULONG      StreamIndex;             // zero based index of stream
    LONG       DefaultKeyFrameRate;     // Key frame rate
    LONG       DefaultPFrameRate;       // Predeicted frames per Key frame
    LONG       DefaultQuality;          // 0 to 10000
    LONG       NumberOfQualitySettings; // How many discreet quality settings?
    LONG       Capabilities;            // CS_CompressionCaps_*
} CSPROPERTY_VIDEOCOMPRESSION_GETINFO_S, *PCSPROPERTY_VIDEOCOMPRESSION_GETINFO_S;

typedef struct {
    CSPROPERTY Property;
    ULONG      StreamIndex;             // zero based index of stream
    LONG       Value;                   // value to get or set
} CSPROPERTY_VIDEOCOMPRESSION_S, *PCSPROPERTY_VIDEOCOMPRESSION_S;

//===========================================================================
// MEDIASUBTYPE_Overlay
#define STATIC_CSDATAFORMAT_SUBTYPE_OVERLAY\
    0xe436eb7fL, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb7f-524f-11ce-9f53-0020af0ba770", CSDATAFORMAT_SUBTYPE_OVERLAY);
#define CSDATAFORMAT_SUBTYPE_OVERLAY DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_OVERLAY)

#define STATIC_CSPROPSETID_OverlayUpdate\
    0x490EA5CFL, 0x7681, 0x11D1, 0xA2, 0x1C, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("490EA5CF-7681-11D1-A21C-00A0C9223196", CSPROPSETID_OverlayUpdate);
#define CSPROPSETID_OverlayUpdate DEFINE_GUIDNAMED(CSPROPSETID_OverlayUpdate)

typedef enum {
    CSPROPERTY_OVERLAYUPDATE_INTERESTS,
    CSPROPERTY_OVERLAYUPDATE_CLIPLIST = 0x1,
    CSPROPERTY_OVERLAYUPDATE_PALETTE = 0x2,
    CSPROPERTY_OVERLAYUPDATE_COLORKEY = 0x4,
    CSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION = 0x8,
    CSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE = 0x10,
    CSPROPERTY_OVERLAYUPDATE_COLORREF = 0x10000000
} CSPROPERTY_OVERLAYUPDATE;

typedef struct {
    ULONG   PelsWidth;
    ULONG   PelsHeight;
    ULONG   BitsPerPel;
    WCHAR   DeviceID[1];
} CSDISPLAYCHANGE, *PCSDISPLAYCHANGE;

#define DEFINE_CSPROPERTY_ITEM_OVERLAYUPDATE_INTERESTS(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_OVERLAYUPDATE_INTERESTS,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_OVERLAYUPDATE_PALETTE(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_OVERLAYUPDATE_PALETTE,\
        NULL,\
        sizeof(CSPROPERTY),\
        0,\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_OVERLAYUPDATE_COLORKEY(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_OVERLAYUPDATE_COLORKEY,\
        NULL,\
        sizeof(CSPROPERTY),\
        sizeof(COLORKEY),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_OVERLAYUPDATE_CLIPLIST(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_OVERLAYUPDATE_CLIPLIST,\
        NULL,\
        sizeof(CSPROPERTY),\
        2 * sizeof(RECT) + sizeof(RGNDATAHEADER),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_OVERLAYUPDATE_VIDEOPOSITION(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION,\
        NULL,\
        sizeof(CSPROPERTY),\
        2 * sizeof(RECT),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_OVERLAYUPDATE_DISPLAYCHANGE(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE,\
        NULL,\
        sizeof(CSPROPERTY),\
        sizeof(CSDISPLAYCHANGE),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_CSPROPERTY_ITEM_OVERLAYUPDATE_COLORREF(Handler)\
    DEFINE_CSPROPERTY_ITEM(\
        CSPROPERTY_OVERLAYUPDATE_COLORREF,\
        (Handler),\
        sizeof(CSPROPERTY),\
        sizeof(COLORREF),\
        NULL,\
        NULL, 0, NULL, NULL, 0)

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_VIDEOCONTROL\
    0x6a2e0670L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0670-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_VIDEOCONTROL);
#define PROPSETID_VIDCAP_VIDEOCONTROL DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOCONTROL)

typedef enum {
    CSPROPERTY_VIDEOCONTROL_CAPS,               // R
    CSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE,  // R O
    CSPROPERTY_VIDEOCONTROL_FRAME_RATES,        // R O
    CSPROPERTY_VIDEOCONTROL_MODE,               // RWO
} CSPROPERTY_VIDCAP_VIDEOCONTROL;

typedef enum {
    CS_VideoControlFlag_FlipHorizontal        = 0x0001,
    CS_VideoControlFlag_FlipVertical          = 0x0002,
    CS_Obsolete_VideoControlFlag_ExternalTriggerEnable = 0x0010,    // ***WARNING *** Flag msimatch with DSHOW.
    CS_Obsolete_VideoControlFlag_Trigger               = 0x0020,  // ***WARNING *** Flag msimatch with DSHOW.
    CS_VideoControlFlag_ExternalTriggerEnable = 0x0004,
    CS_VideoControlFlag_Trigger                      = 0x0008,
} CS_VideoControlFlags;

typedef struct {
    CSPROPERTY Property;
    ULONG      StreamIndex;
    ULONG      VideoControlCaps;                // CS_VideoControlFlags_*
} CSPROPERTY_VIDEOCONTROL_CAPS_S, *PCSPROPERTY_VIDEOCONTROL_CAPS_S;

typedef struct {
    CSPROPERTY Property;
    ULONG      StreamIndex;
    LONG       Mode;                            // CS_VideoControlFlags_*
} CSPROPERTY_VIDEOCONTROL_MODE_S, *PCSPROPERTY_VIDEOCONTROL_MODE_S;

typedef struct {
    CSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      RangeIndex;                      // Index of range
    SIZE       Dimensions;                      // Size of image
    LONGLONG   CurrentActualFrameRate;          // Only correct if pin is open
    LONGLONG   CurrentMaxAvailableFrameRate;    // Max Rate temporarily limited on USB or 1394?
} CSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S, *PCSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S;

// CSPROPERTY_VIDEOCONTROL_FRAME_RATES returns a list of available frame rates in 100 nS units
typedef struct {
    CSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      RangeIndex;                      // Index of range
    SIZE       Dimensions;                      // Size of image
} CSPROPERTY_VIDEOCONTROL_FRAME_RATES_S, *PCSPROPERTY_VIDEOCONTROL_FRAME_RATES_S;

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_DROPPEDFRAMES\
    0xC6E13344L, 0x30AC, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13344-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_DROPPEDFRAMES);
#define PROPSETID_VIDCAP_DROPPEDFRAMES DEFINE_GUIDNAMED(PROPSETID_VIDCAP_DROPPEDFRAMES)

typedef enum {
    CSPROPERTY_DROPPEDFRAMES_CURRENT            // R
} CSPROPERTY_VIDCAP_DROPPEDFRAMES;

typedef struct {
    CSPROPERTY Property;
    LONGLONG   PictureNumber;                   // Current Picture Number
    LONGLONG   DropCount;                       // Count of frames dropped
    ULONG      AverageFrameSize;                // Average size of frames captured
} CSPROPERTY_DROPPEDFRAMES_CURRENT_S, *PCSPROPERTY_DROPPEDFRAMES_CURRENT_S;

//===========================================================================
// VPE

#define STATIC_CSPROPSETID_VPConfig\
    0xbc29a660L, 0x30e3, 0x11d0, 0x9e, 0x69, 0x00, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b
DEFINE_GUIDSTRUCT("bc29a660-30e3-11d0-9e69-00c04fd7c15b", CSPROPSETID_VPConfig);
#define CSPROPSETID_VPConfig DEFINE_GUIDNAMED(CSPROPSETID_VPConfig)

#define STATIC_CSPROPSETID_VPVBIConfig\
    0xec529b00L, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("ec529b00-1a1f-11d1-bad9-00609744111a", CSPROPSETID_VPVBIConfig);
#define CSPROPSETID_VPVBIConfig DEFINE_GUIDNAMED(CSPROPSETID_VPVBIConfig)

// Both of the above property sets use the same list of properties below

typedef enum {
    CSPROPERTY_VPCONFIG_NUMCONNECTINFO,
    CSPROPERTY_VPCONFIG_GETCONNECTINFO,
    CSPROPERTY_VPCONFIG_SETCONNECTINFO,
    CSPROPERTY_VPCONFIG_VPDATAINFO,
    CSPROPERTY_VPCONFIG_MAXPIXELRATE,
    CSPROPERTY_VPCONFIG_INFORMVPINPUT,
    CSPROPERTY_VPCONFIG_NUMVIDEOFORMAT,
    CSPROPERTY_VPCONFIG_GETVIDEOFORMAT,
    CSPROPERTY_VPCONFIG_SETVIDEOFORMAT,
    CSPROPERTY_VPCONFIG_INVERTPOLARITY,
    CSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY,   // E_NOTIMPL for VBI
    CSPROPERTY_VPCONFIG_SCALEFACTOR,            // E_NOTIMPL for VBI
    CSPROPERTY_VPCONFIG_DDRAWHANDLE,
    CSPROPERTY_VPCONFIG_VIDEOPORTID,
    CSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE,
    CSPROPERTY_VPCONFIG_SURFACEPARAMS
} CSPROPERTY_VPCONFIG;

//=========================
// IBasicAudio
//
#define STATIC_CLSID_CsIBasicAudioInterfaceHandler\
    0xb9f8ac3e, 0x0f71, 0x11d2, 0xb7, 0x2c, 0x00, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d
DEFINE_GUIDSTRUCT("b9f8ac3e-0f71-11d2-b72c-00c04fb6bd3d", CLSID_CsIBasicAudioInterfaceHandler);
#define CLSID_CsIBasicAudioInterfaceHandler DEFINE_GUIDNAMED(CLSID_CsIBasicAudioInterfaceHandler)


#if defined(__IVPType__)

typedef struct {
    AMVPSIZE    Size;
    DWORD       MaxPixelsPerSecond;
    DWORD       Reserved;
} CSVPMAXPIXELRATE, *PCSVPMAXPIXELRATE;

typedef struct {
    CSPROPERTY      Property;
    AMVPSIZE        Size;
} CSVPSIZE_PROP, *PCSVPSIZE_PROP;

typedef struct {
    DWORD   dwPitch;
    DWORD   dwXOrigin;
    DWORD   dwYOrigin;
} CSVPSURFACEPARAMS, *PCSVPSURFACEPARAMS;

#else  // !defined(__IVPType__)

#if !defined(__DDRAW_INCLUDED__)

//==========================================================================
// The following definitions must be in sync with DDraw.h in DirectX SDK
//==========================================================================

/*
 * The FourCC code is valid.
 */
#define DDPF_FOURCC                             0x00000004l


typedef struct _DDPIXELFORMAT
{
    DWORD       dwSize;                 // size of structure
    DWORD       dwFlags;                // pixel format flags
    DWORD       dwFourCC;               // (FOURCC code)
    union
    {
    DWORD   dwRGBBitCount;          // how many bits per pixel (BD_1,2,4,8,16,24,32)
    DWORD   dwYUVBitCount;          // how many bits per pixel (BD_4,8,16,24,32)
    DWORD   dwZBufferBitDepth;      // how many bits for z buffers (BD_8,16,24,32)
    DWORD   dwAlphaBitDepth;        // how many bits for alpha channels (BD_1,2,4,8)
    };
    union
    {
    DWORD   dwRBitMask;             // mask for red bit
    DWORD   dwYBitMask;             // mask for Y bits
    };
    union
    {
    DWORD   dwGBitMask;             // mask for green bits
    DWORD   dwUBitMask;             // mask for U bits
    };
    union
    {
    DWORD   dwBBitMask;             // mask for blue bits
    DWORD   dwVBitMask;             // mask for V bits
    };
    union
    {
    DWORD   dwRGBAlphaBitMask;      // mask for alpha channel
    DWORD   dwYUVAlphaBitMask;      // mask for alpha channel
    DWORD   dwRGBZBitMask;          // mask for Z channel
    DWORD   dwYUVZBitMask;          // mask for Z channel
    };
} DDPIXELFORMAT, * LPDDPIXELFORMAT;

#endif // !defined(__DDRAW_INCLUDED__)

//==========================================================================
// End of DDraw.h header info
//==========================================================================

//==========================================================================
// The following definitions must be in sync with DVP.h in DirectX SDK
//==========================================================================

#if !defined(__DVP_INCLUDED__)

typedef struct _DDVIDEOPORTCONNECT {
    DWORD dwSize;           // size of the DDVIDEOPORTCONNECT structure
    DWORD dwPortWidth;      // Width of the video port
    GUID  guidTypeID;       // Description of video port connection
    DWORD dwFlags;          // Connection flags
    DWORD dwReserved1;      // Reserved, set to zero.
} DDVIDEOPORTCONNECT, * LPDDVIDEOPORTCONNECT;

#define DDVPTYPE_E_HREFH_VREFH  \
    0x54F39980L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#define DDVPTYPE_E_HREFL_VREFL  \
    0xE09C77E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#endif // !defined(__DVP_INCLUDED__)

//==========================================================================
// End of DVP.h header info
//==========================================================================


//==========================================================================
// The following definitions must be in sync with VPType.h in AM 2.0 SDK
//==========================================================================

// pixel aspect ratios corresponding to a 720x480 NTSC image or a 720x576 image
typedef enum // AMPixAspectRatio
{
    CS_PixAspectRatio_NTSC4x3,
    CS_PixAspectRatio_NTSC16x9,
    CS_PixAspectRatio_PAL4x3,
    CS_PixAspectRatio_PAL16x9,
} CS_AMPixAspectRatio ;

typedef enum // AMVP_SELECTFORMATBY
{
    CS_AMVP_DO_NOT_CARE,
    CS_AMVP_BEST_BANDWIDTH,
    CS_AMVP_INPUT_SAME_AS_OUTPUT
} CS_AMVP_SELECTFORMATBY;

typedef enum // AMVP_MODE
{
    CS_AMVP_MODE_WEAVE,
    CS_AMVP_MODE_BOBINTERLEAVED,
    CS_AMVP_MODE_BOBNONINTERLEAVED,
    CS_AMVP_MODE_SKIPEVEN,
    CS_AMVP_MODE_SKIPODD
} CS_AMVP_MODE ;

typedef struct tagCS_AMVPDIMINFO      // AMVPDIMINFO
{
    DWORD dwFieldWidth ;            // [out] field width
    DWORD dwFieldHeight ;           // [out] field height
    DWORD dwVBIWidth ;              // [out] VBI data width
    DWORD dwVBIHeight ;             // [out] VBI data height
    RECT  rcValidRegion ;           // [out] valid rect for data cropping
} CS_AMVPDIMINFO, *PCS_AMVPDIMINFO ;

typedef struct tagCS_AMVPDATAINFO   // AMVPDATAINFO
{
    DWORD           dwSize;                 // Size of the struct
    DWORD           dwMicrosecondsPerField; // Time taken by each field
    CS_AMVPDIMINFO  amvpDimInfo;            // Dimensional Information
    DWORD           dwPictAspectRatioX;     // Pict aspect ratio in X dimn
    DWORD           dwPictAspectRatioY;     // Pict aspect ratio in Y dimn
    BOOL            bEnableDoubleClock;     // Videoport should enable double clocking
    BOOL            bEnableVACT;            // Videoport should use an external VACT signal
    BOOL            bDataIsInterlaced;      // Indicates that the signal is interlaced
    LONG            lHalfLinesOdd;          // number of halflines in the odd field
    BOOL            bFieldPolarityInverted; // Device inverts the polarity by default
    DWORD           dwNumLinesInVREF;       // Number of lines of data in VREF
    LONG            lHalfLinesEven;         // number of halflines in the even field
    DWORD           dwReserved1;            // Reserved for future use
} CS_AMVPDATAINFO, *PCS_AMVPDATAINFO;

typedef struct tagCS_AMVPSIZE   // AMVPSIZE
{
    DWORD dwWidth ;                  // [in] width in pixels
    DWORD dwHeight ;                 // [in] height in pixels
} CS_AMVPSIZE, *PCS_AMVPSIZE ;

//==========================================================================
// End of VPType.h header info
//==========================================================================

typedef struct {
    CS_AMVPSIZE     Size;
    DWORD           MaxPixelsPerSecond;
    DWORD           Reserved;
} CSVPMAXPIXELRATE, *PCSVPMAXPIXELRATE;

typedef struct {
    CSPROPERTY      Property;
    CS_AMVPSIZE     Size;
} CSVPSIZE_PROP, *PCSVPSIZE_PROP;

typedef struct {
    DWORD   dwPitch;
    DWORD   dwXOrigin;
    DWORD   dwYOrigin;
} CSVPSURFACEPARAMS, *PCSVPSURFACEPARAMS;

#endif // !defined(__IVPType__)

//
//  IVPNotify event notification
//
#define STATIC_CSEVENTSETID_VPNotify\
    0x20c5598eL, 0xd3c8, 0x11d0, 0x8d, 0xfc, 0x00, 0xc0, 0x4f, 0xd7, 0xc0, 0x8b
DEFINE_GUIDSTRUCT("20c5598e-d3c8-11d0-8dfc-00c04fd7c08b", CSEVENTSETID_VPNotify);
#define CSEVENTSETID_VPNotify DEFINE_GUIDNAMED(CSEVENTSETID_VPNotify)

typedef enum {
    CSEVENT_VPNOTIFY_FORMATCHANGE,
} CSEVENT_VPNOTIFY;

//
//  VIDCAPTOSTI event notification
//
#define STATIC_CSEVENTSETID_VIDCAPTOSTI\
    0xdb47de20, 0xf628, 0x11d1, 0xba, 0x41, 0x0, 0xa0, 0xc9, 0xd, 0x2b, 0x5
DEFINE_GUIDSTRUCT("DB47DE20-F628-11d1-BA41-00A0C90D2B05", CSEVENTSETID_VIDCAPTOSTI);
#define CSEVENTSETID_VIDCAPNotify DEFINE_GUIDNAMED(CSEVENTSETID_VIDCAPTOSTI)

typedef enum {
    CSEVENT_VIDCAPTOSTI_EXT_TRIGGER,
} CSEVENT_VIDCAPTOSTI;


//
//  IVPVBINotify event notification
//
#define STATIC_CSEVENTSETID_VPVBINotify\
    0xec529b01L, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("ec529b01-1a1f-11d1-bad9-00609744111a", CSEVENTSETID_VPVBINotify);
#define CSEVENTSETID_VPVBINotify DEFINE_GUIDNAMED(CSEVENTSETID_VPVBINotify)

typedef enum {
    CSEVENT_VPVBINOTIFY_FORMATCHANGE,
} CSEVENT_VPVBINOTIFY;


//
// closed caption information
//

#define STATIC_CSDATAFORMAT_TYPE_AUXLine21Data \
0x670aea80L, 0x3a82, 0x11d0, 0xb7, 0x9b, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("670aea80-3a82-11d0-b79b-00aa003767a7", CSDATAFORMAT_TYPE_AUXLine21Data);
#define CSDATAFORMAT_TYPE_AUXLine21Data DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_AUXLine21Data)

#define STATIC_CSDATAFORMAT_SUBTYPE_Line21_BytePair \
0x6e8d4a22L, 0x310c, 0x11d0, 0xb7, 0x9a, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("6e8d4a22-310c-11d0-b79a-00aa003767a7", CSDATAFORMAT_SUBTYPE_Line21_BytePair);
#define CSDATAFORMAT_SUBTYPE_Line21_BytePair DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_Line21_BytePair)

#define STATIC_CSDATAFORMAT_SUBTYPE_Line21_GOPPacket \
0x6e8d4a23L, 0x310c, 0x11d0, 0xb7, 0x9a, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("6e8d4a23-310c-11d0-b79a-00aa003767a7", CSDATAFORMAT_SUBTYPE_Line21_GOPPacket);
#define CSDATAFORMAT_SUBTYPE_Line21_GOPPacket DEFINE_GUIDNAMED(CSDATAFORMAT_SUBTYPE_Line21_GOPPacket)

typedef struct _CSGOP_USERDATA {
    ULONG sc;
    ULONG reserved1;
    BYTE cFields;
    CHAR l21Data[3];
} CSGOP_USERDATA, *PCSGOP_USERDATA;

//
// DVD encrypted PACK format type definition
//

#define STATIC_CSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK\
    0xed0b916a, 0x044d, 0x11d1, 0xaa, 0x78, 0x00, 0xc0, 0x4f, 0xc3, 0x1d, 0x60
DEFINE_GUIDSTRUCT("ed0b916a-044d-11d1-aa78-00c04fc31d60", CSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK);
#define CSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK DEFINE_GUIDNAMED(CSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK)

#define CS_AM_UseNewCSSKey    0x1


// -----------------------------------------------------------------------
// CS_AM_CSPROPSETID_TSRateChange property set definitions for time stamp
// rate changes.
// -----------------------------------------------------------------------


#define STATIC_CSPROPSETID_TSRateChange\
    0xa503c5c0, 0x1d1d, 0x11d1, 0xad, 0x80, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0

DEFINE_GUIDSTRUCT("A503C5C0-1D1D-11D1-AD80-444553540000", CSPROPSETID_TSRateChange);
#define CSPROPSETID_TSRateChange DEFINE_GUIDNAMED(CSPROPSETID_TSRateChange)
typedef enum {
    CS_AM_RATE_SimpleRateChange=1,  // rw, use CS_AM_SimpleRateChange
    CS_AM_RATE_ExactRateChange=2,   // rw, use CS_AM_ExactRateChange
    CS_AM_RATE_MaxFullDataRate=3,   // r, use CS_AM_MaxFullDataRate
    CS_AM_RATE_Step=4               // w, use CS_AM_Step
} CS_AM_PROPERTY_TS_RATE_CHANGE;

typedef struct {
    // this is the simplest mechanism to set a time stamp rate change on
    // a filter (simplest for the person setting the rate change, harder
    // for the filter doing the rate change).
    REFERENCE_TIME  StartTime;  //stream time at which to start this rate
    LONG        Rate;       //new rate * 10000 (decimal)
} CS_AM_SimpleRateChange, *PCS_AM_SimpleRateChange;

typedef struct {
    REFERENCE_TIME  OutputZeroTime; //input TS that maps to zero output TS
    LONG        Rate;       //new rate * 10000 (decimal)
} CS_AM_ExactRateChange, *PCS_AM_ExactRateChange;

typedef LONG CS_AM_MaxFullDataRate; //rate * 10000 (decimal)

typedef DWORD CS_AM_Step; // number of frame to step

//===========================================================================
//ENCODER API DEFINITIONS
//===========================================================================

#define STATIC_CSCATEGORY_ENCODER \
    0x19689bf6, 0xc384, 0x48fd, 0xad, 0x51, 0x90, 0xe5, 0x8c, 0x79, 0xf7, 0xb
DEFINE_GUIDSTRUCT("19689BF6-C384-48fd-AD51-90E58C79F70B", CSCATEGORY_ENCODER);
#define CSCATEGORY_ENCODER DEFINE_GUIDNAMED(CSCATEGORY_ENCODER)

#define STATIC_CSCATEGORY_MULTIPLEXER \
    0x7a5de1d3, 0x1a1, 0x452c, 0xb4, 0x81, 0x4f, 0xa2, 0xb9, 0x62, 0x71, 0xe8
DEFINE_GUIDSTRUCT("7A5DE1D3-01A1-452c-B481-4FA2B96271E8", CSCATEGORY_MULTIPLEXER);
#define CSCATEGORY_MULTIPLEXER DEFINE_GUIDNAMED(CSCATEGORY_MULTIPLEXER)

#ifndef __ENCODER_API_GUIDS__
#define __ENCODER_API_GUIDS__

#define STATIC_ENCAPIPARAM_BITRATE \
    0x49cc4c43, 0xca83, 0x4ad4, 0xa9, 0xaf, 0xf3, 0x69, 0x6a, 0xf6, 0x66, 0xdf
DEFINE_GUIDSTRUCT("49CC4C43-CA83-4ad4-A9AF-F3696AF666DF", ENCAPIPARAM_BITRATE);
#define ENCAPIPARAM_BITRATE DEFINE_GUIDNAMED(ENCAPIPARAM_BITRATE)

#define STATIC_ENCAPIPARAM_PEAK_BITRATE \
    0x703f16a9, 0x3d48, 0x44a1, 0xb0, 0x77, 0x1, 0x8d, 0xff, 0x91, 0x5d, 0x19
DEFINE_GUIDSTRUCT("703F16A9-3D48-44a1-B077-018DFF915D19", ENCAPIPARAM_PEAK_BITRATE);
#define ENCAPIPARAM_PEAK_BITRATE DEFINE_GUIDNAMED(ENCAPIPARAM_PEAK_BITRATE)

#define STATIC_ENCAPIPARAM_BITRATE_MODE \
    0xee5fb25c, 0xc713, 0x40d1, 0x9d, 0x58, 0xc0, 0xd7, 0x24, 0x1e, 0x25, 0xf
DEFINE_GUIDSTRUCT("EE5FB25C-C713-40d1-9D58-C0D7241E250F", ENCAPIPARAM_BITRATE_MODE);
#define ENCAPIPARAM_BITRATE_MODE DEFINE_GUIDNAMED(ENCAPIPARAM_BITRATE_MODE)

#define STATIC_CODECAPI_CHANGELISTS \
    0x62b12acf, 0xf6b0, 0x47d9, 0x94, 0x56, 0x96, 0xf2, 0x2c, 0x4e, 0x0b, 0x9d
DEFINE_GUIDSTRUCT("62B12ACF-F6B0-47D9-9456-96F22C4E0B9D", CODECAPI_CHANGELISTS );
#define CODECAPI_CHANGELISTS DEFINE_GUIDNAMED(CODECAPI_CHANGELISTS )

#define STATIC_CODECAPI_VIDEO_ENCODER \
    0x7112e8e1, 0x3d03, 0x47ef, 0x8e, 0x60, 0x03, 0xf1, 0xcf, 0x53, 0x73, 0x01
DEFINE_GUIDSTRUCT("7112E8E1-3D03-47EF-8E60-03F1CF537301", CODECAPI_VIDEO_ENCODER );
#define CODECAPI_VIDEO_ENCODER DEFINE_GUIDNAMED(CODECAPI_VIDEO_ENCODER )

#define STATIC_CODECAPI_AUDIO_ENCODER \
    0xb9d19a3e, 0xf897, 0x429c, 0xbc, 0x46, 0x81, 0x38, 0xb7, 0x27, 0x2b, 0x2d
DEFINE_GUIDSTRUCT("B9D19A3E-F897-429C-BC46-8138B7272B2D", CODECAPI_AUDIO_ENCODER );
#define CODECAPI_AUDIO_ENCODER DEFINE_GUIDNAMED(CODECAPI_AUDIO_ENCODER )

#define STATIC_CODECAPI_SETALLDEFAULTS \
    0x6c5e6a7c, 0xacf8, 0x4f55, 0xa9, 0x99, 0x1a, 0x62, 0x81, 0x09, 0x05, 0x1b
DEFINE_GUIDSTRUCT("6C5E6A7C-ACF8-4F55-A999-1A628109051B", CODECAPI_SETALLDEFAULTS );
#define CODECAPI_SETALLDEFAULTS DEFINE_GUIDNAMED(CODECAPI_SETALLDEFAULTS )

#define STATIC_CODECAPI_ALLSETTINGS \
    0x6a577e92, 0x83e1, 0x4113, 0xad, 0xc2, 0x4f, 0xce, 0xc3, 0x2f, 0x83, 0xa1
DEFINE_GUIDSTRUCT("6A577E92-83E1-4113-ADC2-4FCEC32F83A1", CODECAPI_ALLSETTINGS );
#define CODECAPI_ALLSETTINGS DEFINE_GUIDNAMED(CODECAPI_ALLSETTINGS )

#define STATIC_CODECAPI_SUPPORTSEVENTS \
    0x0581af97, 0x7693, 0x4dbd, 0x9d, 0xca, 0x3f, 0x9e, 0xbd, 0x65, 0x85, 0xa1 
DEFINE_GUIDSTRUCT("0581AF97-7693-4DBD-9DCA-3F9EBD6585A1", CODECAPI_SUPPORTSEVENTS );
#define CODECAPI_SUPPORTSEVENTS DEFINE_GUIDNAMED(CODECAPI_SUPPORTSEVENTS )

#define STATIC_CODECAPI_CURRENTCHANGELIST \
    0x1cb14e83, 0x7d72, 0x4657, 0x83, 0xfd, 0x47, 0xa2, 0xc5, 0xb9, 0xd1, 0x3d 
DEFINE_GUIDSTRUCT("1CB14E83-7D72-4657-83FD-47A2C5B9D13D", CODECAPI_CURRENTCHANGELIST );
#define CODECAPI_CURRENTCHANGELIST DEFINE_GUIDNAMED(CODECAPI_CURRENTCHANGELIST )

#endif // __ENCODER_API_GUIDS__

#ifndef __ENCODER_API_DEFINES__
#define __ENCODER_API_DEFINES__

typedef enum {

    //
    // Bit rate used for encoding is constant
    //
    ConstantBitRate = 0,

    //
    // Bit rate used for encoding is variable with the specified bitrate used
    // as a guaranteed average over a specified window.  The default window 
    // size is considered to be 5 minutes.
    //
    VariableBitRateAverage,

    //
    // Bit rate used for encoding is variable with the specified bitrate used
    // as an average with a peak not to exceed the specified peak bitrate over 
    // a specified window.  The default window size is considered to be 500ms 
    // (classically one GOP).
    //
    VariableBitRatePeak

} VIDEOENCODER_BITRATE_MODE;

#endif // __ENCODER_API_DEFINES__

#endif // !defined(_CSMEDIA_)

