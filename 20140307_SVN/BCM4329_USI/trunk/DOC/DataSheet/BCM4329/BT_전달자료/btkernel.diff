Index: drivers/serial/samsung.c
===================================================================
--- drivers/serial/samsung.c    (revision 668)
+++ drivers/serial/samsung.c    (revision 669)
@@ -682,7 +682,7 @@
         * Ask the core to calculate the divisor for us.
         */

-       baud = uart_get_baud_rate(port, termios, old, 0, 115200*8);
+       baud = uart_get_baud_rate(port, termios, old, 0, 3000000);

        if (baud == 38400 && (port->flags & UPF_SPD_MASK) == UPF_SPD_CUST)
                quot = port->custom_divisor;
Index: arch/arm/mach-s5pv210/Makefile
===================================================================
--- arch/arm/mach-s5pv210/Makefile	(revision 706)
+++ arch/arm/mach-s5pv210/Makefile	(working copy)
@@ -24,6 +24,7 @@
- obj-$(CONFIG_MACH_SMDKV210)	+= mach-smdkv210.o
+ obj-$(CONFIG_MACH_SMDKV210)	+= mach-smdkv210.o bt-rfkill.o
 obj-$(CONFIG_MACH_SMDKC110)	+= mach-smdkc110.o
 obj-$(CONFIG_MACH_SMDKV210)	+= smdkc110-rtc.o
 obj-$(CONFIG_MACH_SMDKC110)	+= smdkc110-rtc.o
Index: arch/arm/mach-s5pv210/include/mach/gpio.h
===================================================================
--- arch/arm/mach-s5pv210/include/mach/gpio.h	(revision 704)
+++ arch/arm/mach-s5pv210/include/mach/gpio.h	(working copy)
@@ -225,7 +225,9 @@
 				 CONFIG_SAMSUNG_GPIO_EXTRA + 1)
 
 #include <asm-generic/gpio.h>
+#include "gpio-wifibt.h"
 #include <plat/gpio-cfg.h>
 
 extern int s3c_gpio_slp_cfgpin(unsigned int pin, unsigned int to);
Index: arch/arm/mach-s5pv210/include/mach/gpio-wifibt.h
===================================================================
--- arch/arm/mach-s5pv210/include/mach/gpio-wifibt.h	(revision 0)
+++ arch/arm/mach-s5pv210/include/mach/gpio-wifibt.h	(revision 0)
@@ -0,0 +1,76 @@
+#ifndef __GPIO_WIFIBT_H_
+#define __GPIO_WIFIBT_H_
+
+//#include <mach/gpio.h>
+
+#define GPIO_LEVEL_LOW      	0
+#define GPIO_LEVEL_HIGH     	1
+#define GPIO_LEVEL_NONE     	2
+#define GPIO_INPUT				0
+#define GPIO_OUTPUT				1
+
+#define WIFI_GPIO_PIN_EN 0 
+#define BT_GPIO_PIN_RST 1
+#define WIFI_GPIO_CDN 2 
+#define WIFI_GPIO_PIN_RST 3
+#define BR_GPIO_PIN_WAKE 5
+
+#define GPIO_BT_UART_RXD		S5PV210_GPA0(4)
+#define GPIO_BT_UART_RXD_AF		2
+
+#define GPIO_BT_UART_TXD		S5PV210_GPA0(5)
+#define GPIO_BT_UART_TXD_AF		2
+
+#define GPIO_BT_UART_CTS		S5PV210_GPA0(6)
+#define GPIO_BT_UART_CTS_AF		2
+
+#define GPIO_BT_UART_RTS		S5PV210_GPA0(7)
+#define GPIO_BT_UART_RTS_AF		2
+
+#define GPIO_WLAN_BT_EN			S5PV210_GPC1(0)
+
+#define GPIO_WLAN_SDIO_CLK      S5PV210_GPG3(0)
+#define GPIO_WLAN_SDIO_CLK_AF   2
+
+#define GPIO_WLAN_SDIO_CMD      S5PV210_GPG3(1)
+#define GPIO_WLAN_SDIO_CMD_AF   2
+
+#define GPIO_WLAN_SDIO_PDN      S5PV210_GPG2(2)
+
+#define GPIO_WLAN_nRST          S5PV210_GPG2(3)
+#define GPIO_WLAN_nRST_AF	1
+
+#define GPIO_WLAN_SDIO_D0       S5PV210_GPG3(3)
+#define GPIO_WLAN_SDIO_D0_AF    2
+
+#define GPIO_WLAN_SDIO_D1       S5PV210_GPG3(4)
+#define GPIO_WLAN_SDIO_D1_AF    2
+
+#define GPIO_WLAN_SDIO_D2       S5PV210_GPG3(5)
+#define GPIO_WLAN_SDIO_D2_AF    2
+
+#define GPIO_WLAN_SDIO_D3       S5PV210_GPG3(6)
+#define GPIO_WLAN_SDIO_D3_AF    2
+
+#define GPIO_BT_WAKE			S5PV210_GPG2(5)
+
+#define GPIO_BT_nRST			S5PV210_GPC1(1)
+
+#define IRQ_WIFI_HOST_WAKE      IRQ_EINT9
+#define GPIO_WLAN_HOST_WAKE		S5PV210_GPH1(1)
+#define GPIO_WLAN_HOST_WAKE_AF		0xF
+
+#define IRQ_BT_HOST_WAKE      IRQ_EINT(27)
+#define GPIO_BT_HOST_WAKE			S5PV210_GPH3(3)
+#define GPIO_BT_HOST_WAKE_AF		0xF
+
+#define 	GPIO_BT_RXD 		S5PV210_GPA0(4)
+#define 	GPIO_BT_RXD_AF 		2
+#define 	GPIO_BT_TXD 		S5PV210_GPA0(5)
+#define 	GPIO_BT_TXD_AF 		2
+#define 	GPIO_BT_CTS 		S5PV210_GPA0(6)
+#define 	GPIO_BT_CTS_AF 		2
+#define 	GPIO_BT_RTS 		S5PV210_GPA0(7)
+#define 	GPIO_BT_RTS_AF 		2
+#endif
+

Property changes on: arch/arm/mach-s5pv210/include/mach/gpio-wifibt.h
___________________________________________________________________
Added: svn:executable
   + *

Index: arch/arm/mach-s5pv210/mach-smdkv210.c
===================================================================
--- arch/arm/mach-s5pv210/mach-smdkv210.c	(revision 709)
+++ arch/arm/mach-s5pv210/mach-smdkv210.c	(working copy)
@@ -42,8 +42,10 @@
 #include <mach/regs-clock.h>
 #include <mach/regs-mem.h>
 #include <mach/gpio.h>
+#include <mach/gpio-wifibt.h>
 #include <mach/gpio-smdkc110.h>
 #include <mach/regs-gpio.h>
+#include <mach/gpio-bank.h>
 //#include <mach/ts-s3c.h>
 #include <mach/adc.h>
 #include <mach/param.h>

@@ -90,7 +93,10 @@
 #include <plat/ajt-ts.h>
 #include <plat/regs-otg.h>
 #include <../../../drivers/video/samsung/s3cfb.h>
 
 /* Following are default values for UCON, ULCON and UFCON UART registers */
 #define S5PV210_UCON_DEFAULT	(S3C2410_UCON_TXILEVEL |	\
 				 S3C2410_UCON_RXILEVEL |	\
@@ -1518,6 +1543,327 @@
 };
 #endif
 
+static struct platform_device sec_device_rfkill = {
+	.name	= "bt_rfkill",
+	.id	= -1,
+};
@@ -1652,6 +1998,9 @@
 	&s3c_device_timer[2],
 	&s3c_device_timer[3],
 #endif
+	&sec_device_rfkill,
 };
 
 static void __init smdkc110_fixup(struct machine_desc *desc, struct tag *tags, char **cmdline, struct meminfo *mi)
Index: arch/arm/mach-s5pv210/bt-rfkill.c
===================================================================
--- arch/arm/mach-s5pv210/bt-rfkill.c	(revision 0)
+++ arch/arm/mach-s5pv210/bt-rfkill.c	(revision 0)
@@ -0,0 +1,268 @@
+/*
+ * Copyright (C) 2010 Samsung Electronics Co., Ltd.
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Modified for Crespo on August, 2010 By Samsung Electronics Co.
+ * This is modified operate according to each status.
+ *
+ */
+
+/* Control bluetooth power for Crespo platform */
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/rfkill.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/wakelock.h>
+#include <linux/irq.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <mach/gpio.h>
+#include <mach/gpio-wifibt.h>
+#include <mach/hardware.h>
+#include <plat/gpio-cfg.h>
+#include <plat/irqs.h>
+
+static struct wake_lock rfkill_wake_lock;
+
+#ifndef	GPIO_LEVEL_LOW
+#define GPIO_LEVEL_LOW		0
+#define GPIO_LEVEL_HIGH		1
+#endif
+
+static struct rfkill *bt_rfk;
+static const char bt_name[] = "bcm4329";
+
+static int bluetooth_set_power(void *data, enum rfkill_user_states state)
+{
+	int ret = 0;
+	int irq;
+	/* BT Host Wake IRQ */
+	irq = IRQ_BT_HOST_WAKE;
+
+	switch (state) {
+
+	case RFKILL_USER_STATE_UNBLOCKED:
+		//printk("[BT] Device Powering ON\n");
+
+		s3c_setup_uart_cfg_gpio(0);
+
+		if (gpio_is_valid(GPIO_WLAN_BT_EN))
+			gpio_direction_output(GPIO_WLAN_BT_EN, GPIO_LEVEL_HIGH);
+
+		if (gpio_is_valid(GPIO_BT_nRST))
+			gpio_direction_output(GPIO_BT_nRST, GPIO_LEVEL_LOW);
+
+		//printk("[BT] GPIO_BT_nRST = %d\n", gpio_get_value(GPIO_BT_nRST));
+
+		/* Set GPIO_BT_WLAN_REG_ON high */
+		s3c_gpio_setpull(GPIO_WLAN_BT_EN, S3C_GPIO_PULL_NONE);
+		gpio_set_value(GPIO_WLAN_BT_EN, GPIO_LEVEL_HIGH);
+
+		s3c_gpio_slp_cfgpin(GPIO_WLAN_BT_EN, S3C_GPIO_SLP_OUT1);
+		s3c_gpio_slp_setpull_updown(GPIO_WLAN_BT_EN, S3C_GPIO_PULL_NONE);
+
+		//printk("[BT] GPIO_WLAN_BT_EN = %d\n", gpio_get_value(GPIO_WLAN_BT_EN));
+		/*
+		 * FIXME sleep should be enabled disabled since the device is
+		 * not booting if its enabled
+		 */
+		/*
+		 * 100msec, delay between reg_on & rst.
+		 * (bcm4329 powerup sequence)
+		 */
+		msleep(100);
+
+		/* Set GPIO_BT_nRST high */
+		s3c_gpio_setpull(GPIO_BT_nRST, S3C_GPIO_PULL_NONE);
+		gpio_set_value(GPIO_BT_nRST, GPIO_LEVEL_HIGH);
+
+		s3c_gpio_slp_cfgpin(GPIO_BT_nRST, S3C_GPIO_SLP_OUT1);
+		s3c_gpio_slp_setpull_updown(GPIO_BT_nRST, S3C_GPIO_PULL_NONE);
+
+		//printk("[BT] GPIO_BT_nRST = %d\n", gpio_get_value(GPIO_BT_nRST));
+
+		/*
+		 * 50msec, delay after bt rst
+		 * (bcm4329 powerup sequence)
+		 */
+		msleep(50);
+
+		//ret = enable_irq_wake(irq);
+		//if (ret < 0)
+		//	printk(KERN_ERR"[BT] set wakeup src failed\n");
+
+		//enable_irq(irq);
+		break;
+
+	case RFKILL_USER_STATE_SOFT_BLOCKED:
+		//printk("[BT] Device Powering OFF\n");
+
+		//ret = disable_irq_wake(irq);
+		//if (ret < 0)
+		//	printk(KERN_ERR"[BT] unset wakeup src failed\n");
+
+		//disable_irq(irq);
+		wake_unlock(&rfkill_wake_lock);
+
+		s3c_gpio_setpull(GPIO_BT_nRST, S3C_GPIO_PULL_NONE);
+		gpio_set_value(GPIO_BT_nRST, GPIO_LEVEL_LOW);
+
+		s3c_gpio_slp_cfgpin(GPIO_BT_nRST, S3C_GPIO_SLP_OUT0);
+		s3c_gpio_slp_setpull_updown(GPIO_BT_nRST, S3C_GPIO_PULL_NONE);
+
+		//printk("[BT] GPIO_BT_nRST = %d\n", gpio_get_value(GPIO_BT_nRST));
+
+		if (gpio_get_value(GPIO_WLAN_nRST) == 0) {
+			s3c_gpio_setpull(GPIO_WLAN_BT_EN, S3C_GPIO_PULL_NONE);
+			gpio_set_value(GPIO_WLAN_BT_EN, GPIO_LEVEL_LOW);
+
+			s3c_gpio_slp_cfgpin(GPIO_WLAN_BT_EN, S3C_GPIO_SLP_OUT0);
+			s3c_gpio_slp_setpull_updown(GPIO_WLAN_BT_EN, S3C_GPIO_PULL_NONE);
+
+			//printk("[BT] GPIO_WLAN_BT_EN = %d\n", gpio_get_value(GPIO_WLAN_BT_EN));
+		}
+
+		break;
+
+	default:
+		printk(KERN_ERR"[BT] Bad bluetooth rfkill state %d\n", state);
+	}
+
+	return 0;
+}
+
+irqreturn_t bt_host_wake_irq_handler(int irq, void *dev_id)
+{
+	//printk("[BT] bt_host_wake_irq_handler start\n");
+
+	if (gpio_get_value(GPIO_BT_HOST_WAKE))
+		wake_lock(&rfkill_wake_lock);
+	else
+		wake_lock_timeout(&rfkill_wake_lock, HZ);
+
+	return IRQ_HANDLED;
+}
+
+static int bt_rfkill_set_block(void *data, bool blocked)
+{
+	unsigned int ret = 0;
+
+	ret = bluetooth_set_power(data, blocked ?
+			RFKILL_USER_STATE_SOFT_BLOCKED :
+			RFKILL_USER_STATE_UNBLOCKED);
+
+	return ret;
+}
+
+static const struct rfkill_ops bt_rfkill_ops = {
+	.set_block = bt_rfkill_set_block,
+};
+
+static int __init bt_rfkill_probe(struct platform_device *pdev)
+{
+	int irq;
+	int ret;
+
+	/* Initialize wake locks */
+	wake_lock_init(&rfkill_wake_lock, WAKE_LOCK_SUSPEND, "bt_host_wake");
+
+	ret = gpio_request(GPIO_WLAN_BT_EN, "GPC");
+	if (ret < 0) {
+		printk(KERN_ERR"[BT] Failed to request GPIO_WLAN_BT_EN!\n");
+		goto err_req_gpio_wlan_bt_en;
+	}
+
+	ret = gpio_request(GPIO_BT_nRST, "GPC");
+	if (ret < 0) {
+		printk(KERN_ERR"[BT] Failed to request GPIO_BT_nRST!\n");
+		goto err_req_gpio_bt_nrst;
+	}
+
+	/* BT Host Wake IRQ */
+	irq = IRQ_BT_HOST_WAKE;
+
+	ret = request_irq(irq, bt_host_wake_irq_handler,
+			IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+			"bt_host_wake_irq_handler", NULL);
+
+	if (ret < 0) {
+		printk(KERN_ERR"[BT] Request_irq failed\n");
+		goto err_req_irq;
+	}
+
+	disable_irq(irq);
+
+	bt_rfk = rfkill_alloc(bt_name, &pdev->dev, RFKILL_TYPE_BLUETOOTH,
+			&bt_rfkill_ops, NULL);
+
+	if (!bt_rfk) {
+		printk(KERN_ERR"[BT] bt_rfk : rfkill_alloc is failed\n");
+		ret = -ENOMEM;
+		goto err_alloc;
+	}
+
+	rfkill_init_sw_state(bt_rfk, 0);
+
+	printk("[BT] rfkill_register(bt_rfk)\n");
+
+	ret = rfkill_register(bt_rfk);
+	if (ret) {
+		printk(KERN_ERR"********ERROR IN REGISTERING THE RFKILL********\n");
+		goto err_register;
+	}
+
+	rfkill_set_sw_state(bt_rfk, 1);
+	bluetooth_set_power(NULL, RFKILL_USER_STATE_UNBLOCKED);
+
+	return ret;
+
+ err_register:
+	rfkill_destroy(bt_rfk);
+
+ err_alloc:
+	free_irq(irq, NULL);
+
+ err_req_irq:
+	gpio_free(GPIO_BT_nRST);
+
+ err_req_gpio_bt_nrst:
+	gpio_free(GPIO_WLAN_BT_EN);
+
+ err_req_gpio_wlan_bt_en:
+	return ret;
+}
+
+static struct platform_driver bt_device_rfkill = {
+	.probe = bt_rfkill_probe,
+	.driver = {
+		.name = "bt_rfkill",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init bt_rfkill_init(void)
+{
+	int rc = 0;
+	rc = platform_driver_register(&bt_device_rfkill);
+
+	return rc;
+}
+
+module_init(bt_rfkill_init);
+MODULE_DESCRIPTION("bt rfkill");
+MODULE_LICENSE("GPL");

Property changes on: arch/arm/mach-s5pv210/bt-rfkill.c
___________________________________________________________________
Added: svn:executable
   + *

Index: arch/arm/configs/bt_android_mtd_defconfig
===================================================================
--- arch/arm/configs/bt_android_mtd_defconfig	(revision 709)
+++ arch/arm/configs/bt_android_mtd_defconfig	(working copy)
@@ -752,11 +608,39 @@
 # CONFIG_HAMRADIO is not set
 # CONFIG_CAN is not set
 # CONFIG_IRDA is not set
-# CONFIG_BT is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_L2CAP_EXT_FEATURES=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_BCSP is not set
+# CONFIG_BT_HCIUART_LL is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
 # CONFIG_AF_RXRPC is not set
@@ -767,7 +651,9 @@
 # Some wireless drivers require a rate control algorithm
 #
 # CONFIG_WIMAX is not set
-# CONFIG_RFKILL is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_PM=y
+# CONFIG_RFKILL_INPUT is not set
 # CONFIG_NET_9P is not set
 # CONFIG_CAIF is not set
 

